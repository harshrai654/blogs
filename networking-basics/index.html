<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking Basics | Learning Loop</title><meta name=keywords content><meta name=description content="In this blog I will try to explain basics of networking concepts and how these concepts are used to create simple to complex networking topologies to transfer data between physical machines and with the use of network namespaces on Linux we will try to simulate various scenarios as we discuss the theory behind them.
Network Segments
A network segment refers to a distinct part of a computer network that is isolated from the remainder of the network by a specific device, such as a repeater, hub, bridge, switch, or router. Within each segment, one or more computers or other hosts may reside.
Depending on how these devices are connected, the network forms L1, L2 or L3 segments, Here the segment are mainly named on the basis of the layer of OSI networking model in which a segment mainly communicates."><meta name=author content><link rel=canonical href=https://harshrai654.github.io/blogs/networking-basics/><link crossorigin=anonymous href=/blogs/assets/css/stylesheet.4a2d4f6ce40ed4a68aae2b504ff6913b1f64bf1b352beea0c885d29c6d987670.css integrity="sha256-Si1PbOQO1KaKritQT/aROx9kvxs1K+6gyIXSnG2YdnA=" rel="preload stylesheet" as=style><link rel=icon href=https://harshrai654.github.io/blogs/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://harshrai654.github.io/blogs/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://harshrai654.github.io/blogs/favicon-32x32.png><link rel=apple-touch-icon href=https://harshrai654.github.io/blogs/apple-touch-icon.png><link rel=mask-icon href=https://harshrai654.github.io/blogs/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://harshrai654.github.io/blogs/networking-basics/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script data-goatcounter=https://ttharsh.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://harshrai654.github.io/blogs/ accesskey=h title="Learning Loop (Alt + H)">Learning Loop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://harshrai654.github.io/blogs/>Home</a></div><h1 class="post-title entry-hint-parent">Networking Basics</h1><div class=post-meta><span title='2026-01-12 22:20:37 +0530 +0530'>January 12, 2026</span>&nbsp;·&nbsp;27 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#network-segments aria-label="Network Segments">Network Segments</a></li><li><a href=#trying-broadcast-domain aria-label="Trying Broadcast Domain">Trying Broadcast Domain</a><ul><li><a href=#network-namespaces aria-label="Network Namespaces">Network Namespaces</a></li><li><a href=#testing-the-setup aria-label="Testing the setup">Testing the setup</a></li></ul></li><li><a href=#l3-segment aria-label="L3 Segment">L3 Segment</a><ul><li><a href=#step-1-ping-triggers-routing-decision-in-ns1 aria-label="Step 1: Ping triggers routing decision in ns1">Step 1: Ping triggers routing decision in ns1</a></li><li><a href=#step-2-first-arp--broadcast-from-ceth1 aria-label="Step 2: First ARP – broadcast from ceth1">Step 2: First ARP – broadcast from ceth1</a><ul><li><a href=#bridge-behaviour-at-this-stage aria-label="Bridge behaviour at this stage">Bridge behaviour at this stage</a></li></ul></li><li><a href=#step-3-arp-reply-from-ceth3--unicast aria-label="Step 3: ARP reply from ceth3 – unicast">Step 3: ARP reply from ceth3 – unicast</a><ul><li><a href=#bridge-behaviour-here aria-label="Bridge behaviour here">Bridge behaviour here</a></li></ul></li><li><a href=#step-4-icmp-echo-request-and-reply-pure-unicast aria-label="Step 4: ICMP echo request and reply (pure unicast)">Step 4: ICMP echo request and reply (pure unicast)</a><ul><li><a href=#bridge-behaviour-during-icmp aria-label="Bridge behaviour during ICMP">Bridge behaviour during ICMP</a></li></ul></li><li><a href=#step-5-why-a-second-arp-is-sent-by-ceth3 aria-label="Step 5: Why a second ARP is sent by ceth3">Step 5: Why a second ARP is sent by ceth3</a><ul><li><a href=#why-ns3-needs-this-arp aria-label="Why ns3 needs this ARP">Why ns3 needs this ARP</a></li></ul></li><li><a href=#step-6-why-this-second-arp-does-not-reach-ceth2 aria-label="Step 6: Why this second ARP does NOT reach ceth2">Step 6: Why this second ARP does NOT reach ceth2</a><ul><li><a href=#bridge-behaviour-for-this-arp aria-label="Bridge behaviour for this ARP">Bridge behaviour for this ARP</a></li></ul></li><li><a href=#final-summary-key-points aria-label="Final summary (key points)">Final summary (key points)</a></li></ul></li><li><a href=#vlan aria-label=VLAN>VLAN</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>In this blog I will try to explain basics of networking concepts and how these concepts are used to create simple to complex networking topologies to transfer data between physical machines and with the use of network namespaces on Linux we will try to simulate various scenarios as we discuss the theory behind them.</p><h2 id=network-segments>Network Segments<a hidden class=anchor aria-hidden=true href=#network-segments>#</a></h2><p>A <em>network segment</em> refers to a distinct part of a computer <a href=https://www.linfo.org/network.html>network</a> that is isolated from the remainder of the network by a specific device, such as a <a href=https://www.linfo.org/repeater.html>repeater</a>, hub, <a href=https://www.linfo.org/bridge.html>bridge</a>, switch, or router. Within each segment, one or more computers or other hosts may reside.
Depending on how these devices are connected, the network forms <strong>L1, L2 or L3 segments</strong>, Here the segment are mainly named on the basis of the layer of OSI networking model in which a segment mainly communicates.</p><p>An <em>L1 segment</em> is formed by a physical connection between networked devices, where each node on a single segment have a common physical layer
When multiple L1 segments are connected by a shared switch (or bridge), an <em>L2 network segment</em> is formed. A L2 segment can also be formed recursively, i.e. merging multiple L2 segments via an upper layer switch to form a tree like topology.</p><p><img alt="Pasted image 20260110205045.png" loading=lazy src=/blogs/media/pasted-image-20260110205045.png></p><p>At its fundamental level, each <strong>L2 (Layer 2) segment</strong> operates as an independent <strong>broadcast domain</strong>. This means that every device connected within that specific segment has the capability to send a message that will be received by <em>all</em> other devices on the same segment. This form of &ldquo;one-to-all&rdquo; communication, known as broadcasting, takes place at <strong>Layer 2 of the OSI Model</strong> (the Data Link Layer), where devices primarily use MAC addresses and Ethernet frames to communicate.
When several individual L2 segments are interconnected or &ldquo;merged&rdquo;: For example, by a network switch, They effectively combine to form a <strong>single, larger L2 segment</strong>. The significant implication of this merging is the creation of a much <strong>bigger broadcast domain</strong>. Within this expanded domain, a broadcast message initiated by any device will now reach <em>every other device</em> across the entire consolidated segment, allowing for broader Layer 2 communication across the network.</p><blockquote><p>Note: VLAN can be used to split broadcast domains at the data link layer, Later on we will see how to use VLAN to partition a broadcast domain within a single L2 segment</p></blockquote><p>The accompanying diagram illustrates the structure of a Layer 2 Ethernet frame. Communication between devices within a Layer 2 segment occurs through the generation of binary payloads conforming to this structure. Our goal is to develop custom Go code for writing raw Ethernet frames to a designated network interface.
<img alt="Pasted image 20260110212923.png" loading=lazy src=/blogs/media/pasted-image-20260110212923.png></p><h2 id=trying-broadcast-domain>Trying Broadcast Domain<a hidden class=anchor aria-hidden=true href=#trying-broadcast-domain>#</a></h2><p>With Linux network namespaces we can simulate a network topology as shown in the diagram above and try to broadcast Ethernet frames with destination MAC address of (<code>ff:ff:ff:ff:ff:ff</code>) and try to send frame to a specific node with its MAC address and see how the whole communication works, But before we jump into lets understand what network namespaces are.</p><h3 id=network-namespaces>Network Namespaces<a hidden class=anchor aria-hidden=true href=#network-namespaces>#</a></h3><p>Linux network namespaces offer a method to simulate a dedicated network environment for a Linux container. This is precisely why containers created by Docker are equipped with their own distinct network interfaces, IP stacks, routing tables, and firewall rules. One can conceptualize network namespaces as operating on a similar principle to C++ namespaces: they establish a scoped environment with its own set of &ldquo;devices&rdquo; that do not conflict with the host machine&rsquo;s hardware, thereby creating a virtual device (a container) within the host system.
We will be taking a slight detour to first understand how we can create a working network topology like above with network namespace on Linux.</p><p>Let&rsquo;s first create a network namespace <code>ns1</code> with <code>ip netns</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns add ns1
</span></span><span class=line><span class=ln>2</span><span class=cl>laborant@ubuntu-01:~$ ip netns list
</span></span><span class=line><span class=ln>3</span><span class=cl>ns1
</span></span></code></pre></div><p>The <code>ip link</code> command is used to display all devices available on the host machine. This command can also be run within a newly created network namespace, such as <code>ns1</code>, by utilizing <code>nsenter</code>. A file is mounted for each new network namespace at <code>/run/netns/&lt;namespace_name></code>, and this mounted file can be used with <code>nsenter</code> to make the specified network namespace active for a current shell session. As shown below, the <code>ns1</code> namespace contains only a loop back device.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl><span class=c1># ON HOST MACHINE</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>laborant@ubuntu-01:~$ ip link list
</span></span><span class=line><span class=ln> 3</span><span class=cl>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class=m>65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln> 5</span><span class=cl>2: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu <span class=m>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    link/ether 3a:4c:de:8c:05:55 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln> 7</span><span class=cl>3: dummy0: &lt;BROADCAST,NOARP&gt; mtu <span class=m>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    link/ether 7a:7e:34:4b:fb:cd brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln> 9</span><span class=cl>4: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc pfifo_fast state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    link/ether ba:58:08:f7:5c:14 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln>11</span><span class=cl>
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=c1># ON NS1 namespace</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>laborant@ubuntu-01:~$ ls -la /run/netns/
</span></span><span class=line><span class=ln>14</span><span class=cl>total <span class=m>0</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>drwxr-xr-x  <span class=m>2</span> root root  <span class=m>60</span> Jan <span class=m>10</span> 16:19 .
</span></span><span class=line><span class=ln>16</span><span class=cl>drwxr-xr-x <span class=m>16</span> root root <span class=m>440</span> Jan <span class=m>10</span> 16:19 ..
</span></span><span class=line><span class=ln>17</span><span class=cl>-r--r--r--  <span class=m>1</span> root root   <span class=m>0</span> Jan <span class=m>10</span> 16:19 ns1
</span></span><span class=line><span class=ln>18</span><span class=cl>
</span></span><span class=line><span class=ln>19</span><span class=cl>laborant@ubuntu-01:~$ sudo nsenter --net<span class=o>=</span>/run/netns/ns1
</span></span><span class=line><span class=ln>20</span><span class=cl>root@ubuntu-01:laborant# ip link list
</span></span><span class=line><span class=ln>21</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></code></pre></div><p>The initial step is to establish a <strong>L1 segment by creating a virtual Ethernet pair device</strong>. One interface of this pair will be positioned within the <code>ns1</code> network namespace, while the other will reside on the host machine. A description of the <code>veth</code> device, available in its manual pages:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=ln> 1</span><span class=cl>The veth devices are virtual Ethernet devices.  They can act as
</span></span><span class=line><span class=ln> 2</span><span class=cl>tunnels between network namespaces to create a bridge to a
</span></span><span class=line><span class=ln> 3</span><span class=cl>physical network device in another namespace, but can also be used
</span></span><span class=line><span class=ln> 4</span><span class=cl>as standalone network devices.
</span></span><span class=line><span class=ln> 5</span><span class=cl>
</span></span><span class=line><span class=ln> 6</span><span class=cl>veth devices are always created in interconnected pairs.  A pair
</span></span><span class=line><span class=ln> 7</span><span class=cl>can be created using the command:
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    # ip link add &lt;p1-name&gt; type veth peer name &lt;p2-name&gt;
</span></span><span class=line><span class=ln>10</span><span class=cl>
</span></span><span class=line><span class=ln>11</span><span class=cl>In the above, p1-name and p2-name are the names assigned to the
</span></span><span class=line><span class=ln>12</span><span class=cl>two connected end points.
</span></span><span class=line><span class=ln>13</span><span class=cl>
</span></span><span class=line><span class=ln>14</span><span class=cl>Packets transmitted on one device in the pair are immediately
</span></span><span class=line><span class=ln>15</span><span class=cl>received on the other device.  When either device is down, the
</span></span><span class=line><span class=ln>16</span><span class=cl>link state of the pair is down.
</span></span></code></pre></div><p>Let&rsquo;s create <code>veth1 ⇿ ceth1</code> pair</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link add veth1 <span class=nb>type</span> veth peer ceth1
</span></span><span class=line><span class=ln>2</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link list <span class=p>|</span> grep <span class=s2>&#34;veth1&#34;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>6: veth1@ceth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu <span class=m>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    link/ether d6:d3:07:0b:a1:ce brd ff:ff:ff:ff:ff:ff
</span></span></code></pre></div><p>Now we need to place one end of the pair inside the <code>ns1</code> namespace and toggle the state of both the ends to <code>UP</code> from <code>DOWN</code> mode</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> ceth1 netns ns1
</span></span><span class=line><span class=ln> 2</span><span class=cl>laborant@ubuntu-01:~$ ip link ls <span class=p>|</span> grep veth1
</span></span><span class=line><span class=ln> 3</span><span class=cl>6: veth1@if5: &lt;BROADCAST,MULTICAST&gt; mtu <span class=m>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    link/ether d6:d3:07:0b:a1:ce brd ff:ff:ff:ff:ff:ff link-netns ns1
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=c1># Here veth1 is in DOWN mode</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>
</span></span><span class=line><span class=ln> 7</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> veth1 up
</span></span><span class=line><span class=ln> 8</span><span class=cl>laborant@ubuntu-01:~$ ip link ls <span class=p>|</span> grep veth1
</span></span><span class=line><span class=ln> 9</span><span class=cl>6: veth1@if5: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class=m>1500</span> qdisc noqueue state LOWERLAYERDOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    link/ether d6:d3:07:0b:a1:ce brd ff:ff:ff:ff:ff:ff link-netns ns1
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1># Now it&#39;s in LOWERLAYERDOWN since the other end is still DOWN</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>
</span></span><span class=line><span class=ln>13</span><span class=cl>
</span></span><span class=line><span class=ln>14</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns <span class=nb>exec</span> ns1 ip link <span class=nb>set</span> ceth1 up
</span></span><span class=line><span class=ln>15</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns <span class=nb>exec</span> ns1 ip link ls
</span></span><span class=line><span class=ln>16</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln>18</span><span class=cl>5: ceth1@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>    link/ether d2:e0:87:f7:79:84 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>
</span></span><span class=line><span class=ln>21</span><span class=cl>laborant@ubuntu-01:~$ ip link ls <span class=p>|</span> grep veth1
</span></span><span class=line><span class=ln>22</span><span class=cl>6: veth1@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>
</span></span><span class=line><span class=ln>24</span><span class=cl><span class=c1># Now both ends are in UP mode</span>
</span></span></code></pre></div><blockquote><p>I have used <code>ip netns exec</code> to run the commands inside <code>ns1</code> namespace, which is an alternative to <code>nsenter</code> .</p></blockquote><p>With the above setup now we have a <em>L1 segment</em> with two devices <code>veth1</code> and <code>ceth1</code>
Now to have a L2 segment we need to repeat the above steps to create multiple such <code>veth</code> pairs and then <strong><em>connect the host end of the pairs to a device of type bridge</em></strong>.</p><p>I have created two more namespaces <code>ns2</code> and <code>ns3</code> with <code>veth2 ↔ ceth2</code> and <code>veth3 ↔ ceth3</code> virtual ETH pairs respectively</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns add ns2
</span></span><span class=line><span class=ln> 2</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns add ns3
</span></span><span class=line><span class=ln> 3</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link add veth2 <span class=nb>type</span> veth peer ceth2
</span></span><span class=line><span class=ln> 4</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link add veth3 <span class=nb>type</span> veth peer ceth3
</span></span><span class=line><span class=ln> 5</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> ceth2 netns ns2
</span></span><span class=line><span class=ln> 6</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> ceth3 netns ns3
</span></span><span class=line><span class=ln> 7</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> veth2 up
</span></span><span class=line><span class=ln> 8</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> veth3 up
</span></span><span class=line><span class=ln> 9</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns <span class=nb>exec</span> ns2 ip link <span class=nb>set</span> ceth2 up
</span></span><span class=line><span class=ln>10</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns <span class=nb>exec</span> ns3 ip link <span class=nb>set</span> ceth3 up
</span></span><span class=line><span class=ln>11</span><span class=cl>laborant@ubuntu-01:~$ ip link list
</span></span><span class=line><span class=ln>12</span><span class=cl>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class=m>65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln>14</span><span class=cl>2: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu <span class=m>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>    link/ether 3a:4c:de:8c:05:55 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln>16</span><span class=cl>3: dummy0: &lt;BROADCAST,NOARP&gt; mtu <span class=m>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>    link/ether 7a:7e:34:4b:fb:cd brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln>18</span><span class=cl>4: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc pfifo_fast state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>    link/ether ba:58:08:f7:5c:14 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln>20</span><span class=cl>6: veth1@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>    link/ether d6:d3:07:0b:a1:ce brd ff:ff:ff:ff:ff:ff link-netns ns1
</span></span><span class=line><span class=ln>22</span><span class=cl>8: veth2@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    link/ether 4a:f7:79:6e:5c:e6 brd ff:ff:ff:ff:ff:ff link-netns ns2
</span></span><span class=line><span class=ln>24</span><span class=cl>10: veth3@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>    link/ether 2a:b9:c0:6d:ed:05 brd ff:ff:ff:ff:ff:ff link-netns ns3
</span></span><span class=line><span class=ln>26</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns <span class=nb>exec</span> ns2 ip link list
</span></span><span class=line><span class=ln>27</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln>29</span><span class=cl>7: ceth2@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>30</span><span class=cl>    link/ether ba:b6:2f:9a:96:71 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=ln>31</span><span class=cl>laborant@ubuntu-01:~$ sudo ip netns <span class=nb>exec</span> ns3 ip link list
</span></span><span class=line><span class=ln>32</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>33</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln>34</span><span class=cl>9: ceth3@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>35</span><span class=cl>    link/ether c6:ab:66:25:73:f9 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span></code></pre></div><p>Now we have all the <code>veth</code> pair in place, Let&rsquo;s create a bridge device on host machine and connect all host end of newly created <code>veth</code> pairs to the bridge</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link add br0 <span class=nb>type</span> bridge
</span></span><span class=line><span class=ln> 2</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> veth1 master br0
</span></span><span class=line><span class=ln> 3</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> veth2 master br0
</span></span><span class=line><span class=ln> 4</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> veth3 master br0
</span></span><span class=line><span class=ln> 5</span><span class=cl>laborant@ubuntu-01:~$ sudo ip link <span class=nb>set</span> br0 up
</span></span><span class=line><span class=ln> 6</span><span class=cl>laborant@ubuntu-01:~$ ip link list
</span></span><span class=line><span class=ln> 7</span><span class=cl>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class=m>65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln> 9</span><span class=cl>2: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu <span class=m>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    link/ether 3a:4c:de:8c:05:55 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln>11</span><span class=cl>3: dummy0: &lt;BROADCAST,NOARP&gt; mtu <span class=m>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    link/ether 7a:7e:34:4b:fb:cd brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln>13</span><span class=cl>4: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc pfifo_fast state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    link/ether ba:58:08:f7:5c:14 brd ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln>15</span><span class=cl>6: veth1@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master br0 state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    link/ether d6:d3:07:0b:a1:ce brd ff:ff:ff:ff:ff:ff link-netns ns1
</span></span><span class=line><span class=ln>17</span><span class=cl>8: veth2@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master br0 state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    link/ether 4a:f7:79:6e:5c:e6 brd ff:ff:ff:ff:ff:ff link-netns ns2
</span></span><span class=line><span class=ln>19</span><span class=cl>10: veth3@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master br0 state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    link/ether 2a:b9:c0:6d:ed:05 brd ff:ff:ff:ff:ff:ff link-netns ns3
</span></span><span class=line><span class=ln>21</span><span class=cl>11: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>    link/ether c6:e2:a8:ee:aa:be brd ff:ff:ff:ff:ff:ff
</span></span></code></pre></div><p>Bridge <code>br0</code> has been designated as the master for <code>veth1</code>, <code>veth2</code>, and <code>veth3</code>. The <code>ip link list</code> output verifies this, indicating <code>br0</code> as the master for each interface, alongside their corresponding pair endpoints (<code>ceth</code>) located within their respective network namespaces. This configuration effectively establishes a Layer 2 segment, interconnecting three devices through the bridge. The subsequent step involves testing both the broadcast domain and individual device connectivity through the transmission of Ethernet frames.</p><h3 id=testing-the-setup>Testing the setup<a hidden class=anchor aria-hidden=true href=#testing-the-setup>#</a></h3><div class=gist-container><script src=https://gist.github.com/harshrai654/775cfdd5415275351f45df70b47448fc.js></script></div><p>This Go utility constructs raw Ethernet frames by sequentially concatenating the necessary components. It begins by appending the 6-byte <strong>destination MAC address</strong> (obtained from user input) to the frame. Next, it adds the 6-byte <strong>source MAC address</strong> (read from the specified network interface). Following this, a 2-byte <strong>EtherType</strong> (0x88B5 in this case) is appended to indicate the protocol carried in the payload. Finally, the actual <strong>payload data</strong> (&ldquo;L2-test-from-go&rdquo;) is added. This ordered byte sequence forms the complete Ethernet frame, which is then sent directly over the network interface using a raw socket (AF_PACKET).</p><p>We have started <code>tcpdump</code> on the host machine to monitor traffic on the <code>br0</code> bridge interface. Correspondingly, <code>tcpdump</code> was also started on the <code>ceth1</code>, <code>ceth2</code>, and <code>ceth3</code> interfaces within the <code>ns1</code>, <code>ns2</code>, and <code>ns3</code> namespaces.
<strong>Host machine:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl><span class=c1># Building the go snippet into executable binary</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>laborant@ubuntu-01:~$ go build -o l2_ping ./l2_ping.go
</span></span><span class=line><span class=ln> 3</span><span class=cl>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=c1># Listen for the traffic on network interfaces ceth1, ceth2 and ceth3 in ns1, ns2 and ns3 network namespaces respectively</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>laborant@ubuntu-01:~$ ip link list <span class=p>|</span> grep br0
</span></span><span class=line><span class=ln> 6</span><span class=cl>6: veth1@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master br0 state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>8: veth2@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master br0 state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>10: veth3@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue master br0 state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>11: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>laborant@ubuntu-01:~$ sudo tcpdump -i br0 -e -n
</span></span><span class=line><span class=ln>11</span><span class=cl>tcpdump: verbose output suppressed, use -v<span class=o>[</span>v<span class=o>]</span>... <span class=k>for</span> full protocol decode
</span></span><span class=line><span class=ln>12</span><span class=cl>listening on br0, link-type EN10MB <span class=o>(</span>Ethernet<span class=o>)</span>, snapshot length <span class=m>262144</span> bytes
</span></span><span class=line><span class=ln>13</span><span class=cl>
</span></span><span class=line><span class=ln>14</span><span class=cl>08:51:05.394642 26:d7:11:b3:c8:e7 &gt; 33:33:00:00:00:02, ethertype IPv6 <span class=o>(</span>0x86dd<span class=o>)</span>, length 70: fe80::24d7:11ff:feb3:c8e7 &gt; ff02::2: ICMP6, router solicitation, length <span class=m>16</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>08:51:06.521846 be:46:f3:5a:2b:27 &gt; 02:77:f4:ad:6d:55, ethertype Unknown <span class=o>(</span>0x88b5<span class=o>)</span>, length 29:
</span></span><span class=line><span class=ln>16</span><span class=cl>        0x0000:  4c32 2d74 <span class=m>6573</span> 742d <span class=m>6672</span> 6f6d 2d67 6f    L2-test-from-go
</span></span></code></pre></div><p><strong>ns1 namespace:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl><span class=c1># Sending frame from ceth1 (ns1) to ceth2 (ns2)</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1># Here `02:77:f4:ad:6d:55` is the MAC address of ceth2 interface in ns2 namespace as can be seen from the output of `ip link list` below</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>root@ubuntu-01:laborant# ./networking/l2_ping ceth1 02:77:f4:ad:6d:55
</span></span><span class=line><span class=ln>4</span><span class=cl>Sent Ethernet frame via ceth1 → 02:77:f4:ad:6d:55
</span></span></code></pre></div><p><strong>ns2 namespace:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl>laborant@ubuntu-01:~$ sudo nsenter --net<span class=o>=</span>/run/netns/ns2 bash
</span></span><span class=line><span class=ln> 2</span><span class=cl>root@ubuntu-01:laborant# ip link list
</span></span><span class=line><span class=ln> 3</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln> 5</span><span class=cl>7: ceth2@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    link/ether 02:77:f4:ad:6d:55 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth2 -e -n
</span></span><span class=line><span class=ln> 8</span><span class=cl>tcpdump: verbose output suppressed, use -v<span class=o>[</span>v<span class=o>]</span>... <span class=k>for</span> full protocol decode
</span></span><span class=line><span class=ln> 9</span><span class=cl>listening on ceth2, link-type EN10MB <span class=o>(</span>Ethernet<span class=o>)</span>, snapshot length <span class=m>262144</span> bytes
</span></span><span class=line><span class=ln>10</span><span class=cl>
</span></span><span class=line><span class=ln>11</span><span class=cl>08:51:05.395138 26:d7:11:b3:c8:e7 &gt; 33:33:00:00:00:02, ethertype IPv6 <span class=o>(</span>0x86dd<span class=o>)</span>, length 70: fe80::24d7:11ff:feb3:c8e7 &gt; ff02::2: ICMP6, router solicitation, length <span class=m>16</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>08:51:06.521868 be:46:f3:5a:2b:27 &gt; 02:77:f4:ad:6d:55, ethertype Unknown <span class=o>(</span>0x88b5<span class=o>)</span>, length 29:
</span></span><span class=line><span class=ln>13</span><span class=cl>        0x0000:  4c32 2d74 <span class=m>6573</span> 742d <span class=m>6672</span> 6f6d 2d67 6f    L2-test-from-go
</span></span></code></pre></div><p><strong>ns3 namespace:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl>laborant@ubuntu-01:~$ sudo nsenter --net<span class=o>=</span>/run/netns/ns3 bash
</span></span><span class=line><span class=ln> 2</span><span class=cl>root@ubuntu-01:laborant# ip link list
</span></span><span class=line><span class=ln> 3</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln> 5</span><span class=cl>9: ceth3@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    link/ether ce:3c:f4:76:12:a3 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth3 -e -n
</span></span><span class=line><span class=ln> 8</span><span class=cl>tcpdump: verbose output suppressed, use -v<span class=o>[</span>v<span class=o>]</span>... <span class=k>for</span> full protocol decode
</span></span><span class=line><span class=ln> 9</span><span class=cl>listening on ceth3, link-type EN10MB <span class=o>(</span>Ethernet<span class=o>)</span>, snapshot length <span class=m>262144</span> bytes
</span></span><span class=line><span class=ln>10</span><span class=cl>
</span></span><span class=line><span class=ln>11</span><span class=cl>08:51:05.394921 26:d7:11:b3:c8:e7 &gt; 33:33:00:00:00:02, ethertype IPv6 <span class=o>(</span>0x86dd<span class=o>)</span>, length 70: fe80::24d7:11ff:feb3:c8e7 &gt; ff02::2: ICMP6, router solicitation, length <span class=m>16</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>08:51:06.521858 be:46:f3:5a:2b:27 &gt; 02:77:f4:ad:6d:55, ethertype Unknown <span class=o>(</span>0x88b5<span class=o>)</span>, length 29:
</span></span><span class=line><span class=ln>13</span><span class=cl>        0x0000:  4c32 2d74 <span class=m>6573</span> 742d <span class=m>6672</span> 6f6d 2d67 6f    L2-test-from-go
</span></span></code></pre></div><p>Upon an initial transmission of a frame from <code>ceth1</code> to <code>ceth2</code>, it first arrives at the bridge through <code>veth1</code>, which is the corresponding host end of the <code>ceth1</code> interface. Because the bridge has no prior record of the Ethernet frame&rsquo;s destination MAC address, it consequently floods this frame to all connected ports. This action clarifies why the Ethernet frame is observable in <code>ceth3</code>&rsquo;s <code>tcpdump</code>. Nevertheless, following this initial transfer, the bridge learns and stores the source MAC address (corresponding to the <code>ceth1</code> ↔ <code>veth1</code> connection) and its associated port within its Forwarding Database (FDB). Consequently, when a frame is subsequently sent in the opposite direction, from <code>ceth2</code> to <code>ceth1</code>, it will not be flooded to <code>ceth2</code>. This is because of the bridge now possessing knowledge of the precise port for the destination MAC address linked to the <code>veth1</code> ↔ <code>ceth1</code> pair.</p><p><strong>ns1 namespace:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl><span class=c1># For reverse transmission from ceth2 -&gt; ceth1, listening for traffic on ceth1 interface</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth1 -e -n
</span></span><span class=line><span class=ln>3</span><span class=cl>tcpdump: verbose output suppressed, use -v<span class=o>[</span>v<span class=o>]</span>... <span class=k>for</span> full protocol decode
</span></span><span class=line><span class=ln>4</span><span class=cl>listening on ceth1, link-type EN10MB <span class=o>(</span>Ethernet<span class=o>)</span>, snapshot length <span class=m>262144</span> bytes
</span></span><span class=line><span class=ln>5</span><span class=cl>09:24:00.347717 02:77:f4:ad:6d:55 &gt; be:46:f3:5a:2b:27, ethertype Unknown <span class=o>(</span>0x88b5<span class=o>)</span>, length 29:
</span></span><span class=line><span class=ln>6</span><span class=cl>        0x0000:  4c32 2d74 <span class=m>6573</span> 742d <span class=m>6672</span> 6f6d 2d67 6f    L2-test-from-go
</span></span></code></pre></div><p><strong>ns2 namespace:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl><span class=c1># Sending frame from ceth2</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>root@ubuntu-01:laborant# ./networking/l2_ping ceth2 be:46:f3:5a:2b:27
</span></span><span class=line><span class=ln>3</span><span class=cl>Sent Ethernet frame via ceth2 → be:46:f3:5a:2b:27
</span></span></code></pre></div><p><strong>ns3 namespace:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>laborant@ubuntu-01:~$ sudo nsenter --net<span class=o>=</span>/run/netns/ns3 bash
</span></span><span class=line><span class=ln>2</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth3 -e -n
</span></span><span class=line><span class=ln>3</span><span class=cl>tcpdump: verbose output suppressed, use -v<span class=o>[</span>v<span class=o>]</span>... <span class=k>for</span> full protocol decode
</span></span><span class=line><span class=ln>4</span><span class=cl>listening on ceth3, link-type EN10MB <span class=o>(</span>Ethernet<span class=o>)</span>, snapshot length <span class=m>262144</span> bytes
</span></span><span class=line><span class=ln>5</span><span class=cl>
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=c1># No traffic visible on ceth3</span>
</span></span></code></pre></div><p>The preceding tests have illustrated the functionality of L2 segments and broadcast domains. We have not yet addressed L3 segments or IP packets, as the current setup&rsquo;s interfaces lack IP assignments, with communication happening at the <strong>L2 layer via MAC addresses</strong>. Moving forward, we will investigate how Layer 2 and Layer 3 cooperate to facilitate packet transmission using IP addresses.</p><h2 id=l3-segment>L3 Segment<a hidden class=anchor aria-hidden=true href=#l3-segment>#</a></h2><p>To enable communication using IP addresses, it&rsquo;s necessary to first assign an IP address to every machine (or, in this context, to each <code>ceth</code> network interface of a network namespace). The <code>ip addr add</code> command facilitates this process.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>laborant@ubuntu-01:~$ sudo nsenter --net<span class=o>=</span>/run/netns/ns1 bash
</span></span><span class=line><span class=ln>2</span><span class=cl>root@ubuntu-01:laborant# ip addr add dev ceth1 192.168.0.1/24
</span></span><span class=line><span class=ln>3</span><span class=cl>
</span></span><span class=line><span class=ln>4</span><span class=cl>root@ubuntu-01:laborant# ip addr list <span class=p>|</span> grep ceth1
</span></span><span class=line><span class=ln>5</span><span class=cl>5: ceth1@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>6</span><span class=cl>    inet 192.168.0.1/24 scope global ceth1
</span></span></code></pre></div><p>Upon assigning an IP address and its corresponding subnet mask to an interface, the kernel automatically adds a route derived from the subnet mask&rsquo;s information.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>root@ubuntu-01:laborant# ip route list
</span></span><span class=line><span class=ln>2</span><span class=cl>192.168.0.0/24 dev ceth1 proto kernel scope link src 192.168.0.1
</span></span></code></pre></div><p>Consequently, all traffic destined for the <code>192.168.0.0/24</code> subnet will be directed through the <code>ceth1</code> interface. Initially, all nodes (namespaces) will be assigned IP addresses, ensuring they are all part of the same subnet and reside within a single broadcast domain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>root@ubuntu-01:laborant# ip addr list <span class=p>|</span> grep ceth3
</span></span><span class=line><span class=ln>2</span><span class=cl>9: ceth3@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    inet 192.168.0.3/24 scope global ceth3
</span></span><span class=line><span class=ln>4</span><span class=cl>
</span></span><span class=line><span class=ln>5</span><span class=cl>root@ubuntu-01:laborant# ip addr list <span class=p>|</span> grep ceth2
</span></span><span class=line><span class=ln>6</span><span class=cl>7: ceth2@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>7</span><span class=cl>    inet 192.168.0.2/24 scope global ceth2
</span></span></code></pre></div><p>An IP packet also has source and destination IP addresses in its header and the whole IP packet is actually the payload of the Ethernet frame that we have seen above. Any L2 device will only deal with Ethernet frame headers and will treat anything inside the payload as it is, we have already seen this by sending raw bytes of string <code>L2-test-from-go</code> as the payload of the Ethernet frame while building the frame with <code>l2_send</code> go utility binary.
<img alt="Pasted image 20260111171113.png" loading=lazy src=/blogs/media/pasted-image-20260111171113.png>
If we send a <code>ping</code> (<a href=https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol>ICMP packet</a>) from <code>ceth1</code> to <code>192.168.0.3</code> i.e. node 3 with <code>ceth3</code> interface then the sender needs to figure out the destination MAC address as ping will only populate the source and destination IP address. <strong>ARP (Address resolution protocol)</strong> comes into play to resolve the MAC address for a given IP address, Lets see it in action by capturing the packets coming to bridge <code>br0</code> and all interfaces <code>ceth0, ceth1 and ceth3</code> when we send the ping message.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>root@ubuntu-01:laborant# ping -c <span class=m>1</span> 192.168.0.3
</span></span><span class=line><span class=ln>2</span><span class=cl>PING 192.168.0.3 <span class=o>(</span>192.168.0.3<span class=o>)</span> 56<span class=o>(</span>84<span class=o>)</span> bytes of data.
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=m>64</span> bytes from 192.168.0.3: <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>1</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.624 ms
</span></span><span class=line><span class=ln>4</span><span class=cl>
</span></span><span class=line><span class=ln>5</span><span class=cl>--- 192.168.0.3 ping statistics ---
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=m>1</span> packets transmitted, <span class=m>1</span> received, 0% packet loss, <span class=nb>time</span> 0ms
</span></span><span class=line><span class=ln>7</span><span class=cl>rtt min/avg/max/mdev <span class=o>=</span> 0.624/0.624/0.624/0.000 ms
</span></span></code></pre></div><h3 id=step-1-ping-triggers-routing-decision-in-ns1>Step 1: Ping triggers routing decision in <code>ns1</code><a hidden class=anchor aria-hidden=true href=#step-1-ping-triggers-routing-decision-in-ns1>#</a></h3><p>In <code>ns1</code>, the routing table is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>root@ubuntu-01:laborant# ip route
</span></span><span class=line><span class=ln>2</span><span class=cl>192.168.0.0/24 dev ceth1 proto kernel scope link src 192.168.0.1
</span></span></code></pre></div><p>So when I run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>root@ubuntu-01:laborant# ping -c <span class=m>1</span> 192.168.0.3
</span></span></code></pre></div><p>the kernel in <strong>ns1</strong> decides:</p><ul><li>The destination IP is in the same subnet</li><li>The packet must go out via <code>ceth1</code></li><li>No router or gateway is involved</li></ul><p>At this point:</p><ul><li>An ICMP Echo Request is created at L3 (IP layer)</li><li><strong>No Ethernet frame can be built yet</strong>, because the destination MAC for <code>192.168.0.3</code> is unknown</li></ul><p>This missing MAC address is what triggers ARP.</p><h3 id=step-2-first-arp--broadcast-from-ceth1>Step 2: First ARP – broadcast from <code>ceth1</code><a hidden class=anchor aria-hidden=true href=#step-2-first-arp--broadcast-from-ceth1>#</a></h3><p>Because <code>ns1</code> does not know the MAC for <code>192.168.0.3</code>, it sends an ARP request.
On <strong>br0</strong>, <code>tcpdump -i br0 -e -n -vv</code> shows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>be:46:f3:5a:2b:27 &gt; ff:ff:ff:ff:ff:ff, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>,
</span></span><span class=line><span class=ln>2</span><span class=cl>Request who-has 192.168.0.3 tell 192.168.0.1
</span></span></code></pre></div><p>Important details here:</p><ul><li>Source MAC: <code>be:46:f3:5a:2b:27</code> (MAC of <code>ceth1</code>)</li><li>Destination MAC: <code>ff:ff:ff:ff:ff:ff</code> (broadcast)</li><li>This ARP is generated by the <strong>IP stack in ns1</strong>, not by the bridge</li></ul><h4 id=bridge-behaviour-at-this-stage>Bridge behaviour at this stage<a hidden class=anchor aria-hidden=true href=#bridge-behaviour-at-this-stage>#</a></h4><p>When this frame enters <code>br0</code> via <code>veth1</code>:</p><ol><li>The bridge <strong>learns the source MAC</strong>:</li></ol><pre tabindex=0><code>be:46:f3:5a:2b:27 → veth1
</code></pre><ol start=2><li>Because the destination MAC is broadcast, the bridge <strong>floods</strong> the frame to all other ports (broadcast domain)
This explains why:<ul><li><code>ceth3</code> sees the ARP request (expected, it owns 192.168.0.3)</li><li><code>ceth2</code> also sees the ARP request, even though it is not involved:</li></ul></li></ol><pre tabindex=0><code>be:46:f3:5a:2b:27 &gt; ff:ff:ff:ff:ff:ff, ARP who-has 192.168.0.3 tell 192.168.0.1
</code></pre><h3 id=step-3-arp-reply-from-ceth3--unicast>Step 3: ARP reply from <code>ceth3</code> – unicast<a hidden class=anchor aria-hidden=true href=#step-3-arp-reply-from-ceth3--unicast>#</a></h3><p>Since <code>ns3</code> owns <code>192.168.0.3</code>, it replies with an ARP reply.
On <strong>br0</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>ce:3c:f4:76:12:a3 &gt; be:46:f3:5a:2b:27, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>,
</span></span><span class=line><span class=ln>2</span><span class=cl>Reply 192.168.0.3 is-at ce:3c:f4:76:12:a3
</span></span></code></pre></div><p>Key points:</p><ul><li>Source MAC: <code>ce:3c:f4:76:12:a3</code> (MAC of <code>ceth3</code>)</li><li>Destination MAC: <code>be:46:f3:5a:2b:27</code> (MAC of <code>ceth1</code>)</li><li>This is a <strong>unicast</strong> ARP reply - targeted for <code>ceth1</code></li></ul><h4 id=bridge-behaviour-here>Bridge behaviour here<a hidden class=anchor aria-hidden=true href=#bridge-behaviour-here>#</a></h4><p>When this frame enters <code>br0</code> via <code>veth3</code>:</p><ol><li>The bridge learns another MAC:</li></ol><pre tabindex=0><code>ce:3c:f4:76:12:a3 → veth3
</code></pre><ol start=2><li>The destination MAC (<code>be:46:f3:5a:2b:27</code>) is already known</li><li>The frame is forwarded <strong>only to veth1</strong>
Because of this:</li></ol><ul><li><code>ceth1</code> sees the ARP reply</li><li><code>ceth2</code> does <strong>not</strong> see it
This is the first point where flooding stops and unicast forwarding begins.</li></ul><h3 id=step-4-icmp-echo-request-and-reply-pure-unicast>Step 4: ICMP echo request and reply (pure unicast)<a hidden class=anchor aria-hidden=true href=#step-4-icmp-echo-request-and-reply-pure-unicast>#</a></h3><p>After receiving the ARP reply, <code>ns1</code> now has an ARP cache entry:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>root@ubuntu-01:laborant# ip neighbour show
</span></span><span class=line><span class=ln>2</span><span class=cl>192.168.0.3 dev ceth1 lladdr ce:3c:f4:76:12:a3 STALE
</span></span></code></pre></div><p>Now <code>ns1</code> can finally construct the Ethernet frame for the ICMP packet.
On <strong>br0</strong>, the ICMP Echo Request appears as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>be:46:f3:5a:2b:27 &gt; ce:3c:f4:76:12:a3, ethertype IPv4 <span class=o>(</span>0x0800<span class=o>)</span>,
</span></span><span class=line><span class=ln>2</span><span class=cl>192.168.0.1 &gt; 192.168.0.3: ICMP <span class=nb>echo</span> request
</span></span></code></pre></div><p>The reply from <code>ns3</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>ce:3c:f4:76:12:a3 &gt; be:46:f3:5a:2b:27, ethertype IPv4 <span class=o>(</span>0x0800<span class=o>)</span>,
</span></span><span class=line><span class=ln>2</span><span class=cl>192.168.0.3 &gt; 192.168.0.1: ICMP <span class=nb>echo</span> **reply**
</span></span></code></pre></div><h4 id=bridge-behaviour-during-icmp>Bridge behaviour during ICMP<a hidden class=anchor aria-hidden=true href=#bridge-behaviour-during-icmp>#</a></h4><p>At this point:</p><ul><li>The bridge FDB (Forwarding database) already contains both MACs</li><li>Every ICMP frame is forwarded <strong>only between veth1 and veth3</strong></li><li>No flooding occurs</li><li><code>ceth2</code> sees no ICMP traffic at all
This confirms that the bridge is now operating in fully learned unicast mode.</li></ul><h3 id=step-5-why-a-second-arp-is-sent-by-ceth3>Step 5: Why a second ARP is sent by <code>ceth3</code><a hidden class=anchor aria-hidden=true href=#step-5-why-a-second-arp-is-sent-by-ceth3>#</a></h3><p>A few seconds later, this appears on <strong>br0</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>ce:3c:f4:76:12:a3 &gt; be:46:f3:5a:2b:27, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>,
</span></span><span class=line><span class=ln>2</span><span class=cl>Request who-has 192.168.0.1 tell 192.168.0.3
</span></span></code></pre></div><p>This often causes confusion.
Important clarifications:</p><ul><li>This is <strong>not reverse ARP (RARP)</strong></li><li>This is a normal ARP request initiated by <code>ns3</code></li></ul><h4 id=why-ns3-needs-this-arp>Why ns3 needs this ARP<a hidden class=anchor aria-hidden=true href=#why-ns3-needs-this-arp>#</a></h4><p>In <code>ns3</code>, the ARP entry for <code>192.168.0.1</code> is in <code>STALE</code> state:
Linux neighbour entries:</p><ul><li>Age out over time</li><li>ICMP traffic alone does not guarantee permanent freshness</li><li>When the entry is stale and traffic is needed, Linux probes using ARP
So ns3 asks again:<blockquote><p>“Who has 192.168.0.1?”</p></blockquote></li></ul><h3 id=step-6-why-this-second-arp-does-not-reach-ceth2>Step 6: Why this second ARP does NOT reach <code>ceth2</code><a hidden class=anchor aria-hidden=true href=#step-6-why-this-second-arp-does-not-reach-ceth2>#</a></h3><p>This is the most subtle and important point.
Look closely at the Ethernet header:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>ce:3c:f4:76:12:a3 &gt; be:46:f3:5a:2b:27, ethertype ARP
</span></span></code></pre></div><p>The destination MAC is <strong>not broadcast</strong>.
This means:</p><ul><li><code>ns3</code> already knows the MAC address of <code>192.168.0.1</code></li><li>Therefore it sends a <strong>unicast ARP request</strong></li></ul><h4 id=bridge-behaviour-for-this-arp>Bridge behaviour for this ARP<a hidden class=anchor aria-hidden=true href=#bridge-behaviour-for-this-arp>#</a></h4><p>When the frame enters <code>br0</code> via <code>veth3</code>:</p><ol><li>The bridge already has this FDB entry:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>be:46:f3:5a:2b:27 → veth1
</span></span></code></pre></div><ol start=2><li>The destination MAC is known</li><li>The bridge forwards the frame <strong>only to veth1</strong></li><li>No flooding occurs</li></ol><p>As a result:</p><ul><li><code>ceth1</code> sees the ARP request and replies</li><li><code>ceth2</code> sees <strong>nothing</strong>, even though this is an ARP request</li></ul><h3 id=final-summary-key-points>Final summary (key points)<a hidden class=anchor aria-hidden=true href=#final-summary-key-points>#</a></h3><ol><li>A <code>ping</code> first triggers ARP because the destination MAC is unknown.</li><li>The <strong>first ARP</strong> is broadcast and flooded across the bridge.</li><li>The ARP reply allows the bridge to learn MAC locations.</li><li>ICMP traffic then flows purely as unicast.</li><li>ARP cache entries can become <code>STALE</code>, triggering <strong>additional ARP probes</strong>.</li><li>These later ARPs can be <strong>unicast</strong>, not broadcast.</li><li>Because the bridge already knows the destination MAC, it forwards such ARPs only to the correct port.</li><li>This is why <code>ceth2</code> saw the first ARP but did <strong>not</strong> see the second one.</li></ol><p>Overall, this trace cleanly demonstrates:</p><ul><li>ARP is always generated by hosts (namespaces), not by the bridge</li><li>The Linux bridge is strictly Layer 2, using only its FDB to forward frames</li><li>Flooding happens only until MAC learning converges<blockquote><p>ARP traffic can be seen in your home router as well by running <code>tcpdump</code> on the Wi-Fii interface.</p></blockquote></li></ul><h2 id=vlan>VLAN<a hidden class=anchor aria-hidden=true href=#vlan>#</a></h2><p>Lets modify the setup to add 3 more network namespaces representing 3 more nodes connected to the same bridge but on a different subnet - <code>192.168.1.0/24</code>
Now if we have following new node configurations:</p><table><thead><tr><th>Interface</th><th>Namespace</th><th>IP</th></tr></thead><tbody><tr><td><code>ceth4</code></td><td><code>ns4</code></td><td><code>192.168.1.1/24</code></td></tr><tr><td><code>ceth5</code></td><td><code>ns5</code></td><td><code>192.168.1.2/24</code></td></tr><tr><td><code>ceth6</code></td><td><code>ns6</code></td><td><code>192.168.1.3/24</code></td></tr></tbody></table><p>When <code>br0</code> is configured as the master on their host ends, all six nodes share a single broadcast domain. Since a bridge operates as a Layer 2 device, an ARP flood message will reach every node within this broadcast domain. Consequently, an ARP request sent during a ping from <code>192.168.1.2</code> to <code>192.168.1.3</code> will be heard by all nodes in the <code>192.168.0.0/24</code> subnet. This creates an undesirable overlap between the network traffic of two subnets.</p><p><code>ping 192.168.1.2 -> 192.168.1.3</code> (192.168.1.0/24 subnet traffic)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl>root@ubuntu-01:laborant# ip addr list
</span></span><span class=line><span class=ln> 2</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln> 4</span><span class=cl>12: ceth4@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    link/ether 1a:cc:a5:0b:b3:52 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    inet 192.168.1.2/24 scope global ceth4
</span></span><span class=line><span class=ln> 7</span><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=ln> 8</span><span class=cl>    inet6 fe80::18cc:a5ff:fe0b:b352/64 scope link
</span></span><span class=line><span class=ln> 9</span><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=ln>10</span><span class=cl>root@ubuntu-01:laborant# ping -c <span class=m>1</span> 192.168.1.3
</span></span><span class=line><span class=ln>11</span><span class=cl>PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span> 56<span class=o>(</span>84<span class=o>)</span> bytes of data.
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=m>64</span> bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>1</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.098 ms
</span></span><span class=line><span class=ln>13</span><span class=cl>
</span></span><span class=line><span class=ln>14</span><span class=cl>--- 192.168.1.3 ping statistics ---
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=m>1</span> packets transmitted, <span class=m>1</span> received, 0% packet loss, <span class=nb>time</span> 0ms
</span></span><span class=line><span class=ln>16</span><span class=cl>rtt min/avg/max/mdev <span class=o>=</span> 0.098/0.098/0.098/0.000 ms
</span></span></code></pre></div><p><code>tcpdump</code> on<code> 192.168.1.3</code> node</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl>root@ubuntu-01:laborant# ip addr list
</span></span><span class=line><span class=ln> 2</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln> 4</span><span class=cl>16: ceth6@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    link/ether 4a:e8:06:19:53:68 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    inet 192.168.1.3/24 scope global ceth6
</span></span><span class=line><span class=ln> 7</span><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=ln> 8</span><span class=cl>    inet6 fe80::48e8:6ff:fe19:5368/64 scope link
</span></span><span class=line><span class=ln> 9</span><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=ln>10</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth6 -e -n
</span></span><span class=line><span class=ln>11</span><span class=cl>tcpdump: verbose output suppressed, use -v<span class=o>[</span>v<span class=o>]</span>... <span class=k>for</span> full protocol decode
</span></span><span class=line><span class=ln>12</span><span class=cl>listening on ceth6, link-type EN10MB <span class=o>(</span>Ethernet<span class=o>)</span>, snapshot length <span class=m>262144</span> bytes
</span></span><span class=line><span class=ln>13</span><span class=cl>18:06:38.439217 1a:cc:a5:0b:b3:52 &gt; ff:ff:ff:ff:ff:ff, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>, length 42: Request who-has 192.168.1.3 tell 192.168.1.2, length <span class=m>28</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>18:06:38.439239 4a:e8:06:19:53:68 &gt; 1a:cc:a5:0b:b3:52, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>, length 42: Reply 192.168.1.3 is-at 4a:e8:06:19:53:68, length <span class=m>28</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>18:06:38.439257 1a:cc:a5:0b:b3:52 &gt; 4a:e8:06:19:53:68, ethertype IPv4 <span class=o>(</span>0x0800<span class=o>)</span>, length 98: 192.168.1.2 &gt; 192.168.1.3: ICMP <span class=nb>echo</span> request, id 2348, seq 1, length <span class=m>64</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>18:06:38.439269 4a:e8:06:19:53:68 &gt; 1a:cc:a5:0b:b3:52, ethertype IPv4 <span class=o>(</span>0x0800<span class=o>)</span>, length 98: 192.168.1.3 &gt; 192.168.1.2: ICMP <span class=nb>echo</span> reply, id 2348, seq 1, length <span class=m>64</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>18:06:43.593966 4a:e8:06:19:53:68 &gt; 1a:cc:a5:0b:b3:52, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>, length 42: Request who-has 192.168.1.2 tell 192.168.1.3, length <span class=m>28</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>18:06:43.593994 1a:cc:a5:0b:b3:52 &gt; 4a:e8:06:19:53:68, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>, length 42: Reply 192.168.1.2 is-at 1a:cc:a5:0b:b3:52, length <span class=m>28</span>
</span></span></code></pre></div><p>ARP floods are also visible in <code>tcpdump</code> of <code>ceth3</code> interface with IP <code>192.168.0.3</code> of <code>192.168.0.0/24</code> subnet</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl>oot@ubuntu-01:laborant# ip link list
</span></span><span class=line><span class=ln> 2</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln> 4</span><span class=cl>9: ceth3@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    link/ether 52:f2:9f:46:e4:69 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>root@ubuntu-01:laborant# ip addr list
</span></span><span class=line><span class=ln> 7</span><span class=cl>1: lo: &lt;LOOPBACK&gt; mtu <span class=m>65536</span> qdisc noop state DOWN group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span class=line><span class=ln> 9</span><span class=cl>9: ceth3@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class=m>1500</span> qdisc noqueue state UP group default qlen <span class=m>1000</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    link/ether 52:f2:9f:46:e4:69 brd ff:ff:ff:ff:ff:ff link-netnsid <span class=m>0</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    inet 192.168.0.3/24 scope global ceth3
</span></span><span class=line><span class=ln>12</span><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=ln>13</span><span class=cl>    inet6 fe80::50f2:9fff:fe46:e469/64 scope link
</span></span><span class=line><span class=ln>14</span><span class=cl>       valid_lft forever preferred_lft forever
</span></span><span class=line><span class=ln>15</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth3 -e -n
</span></span><span class=line><span class=ln>16</span><span class=cl>tcpdump: verbose output suppressed, use -v<span class=o>[</span>v<span class=o>]</span>... <span class=k>for</span> full protocol decode
</span></span><span class=line><span class=ln>17</span><span class=cl>listening on ceth3, link-type EN10MB <span class=o>(</span>Ethernet<span class=o>)</span>, snapshot length <span class=m>262144</span> bytes
</span></span><span class=line><span class=ln>18</span><span class=cl>18:06:38.439221 1a:cc:a5:0b:b3:52 &gt; ff:ff:ff:ff:ff:ff, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>, length 42: Request who-has 192.168.1.3 tell 192.168.1.2, length <span class=m>28</span>
</span></span></code></pre></div><p>And the reason is simple: the destination MAC address for ARP request <strong>&ldquo;who-has 192.168.1.3 tell 192.168.1.2&rdquo;</strong> is <code>ff:ff:ff:ff:ff:ff</code>, which means the bridge will broadcast the message to all connected ports. Hence, all interfaces of the other subnet will also receive the ARP request. This is undesirable, as subnets are mainly created to group traffic between different types of entities in a single network.</p><p>VLAN tagging can be used to tag nodes of one subnet with a <code>id</code> which helps in partitioning the broadcast domain.
<img alt="Pasted image 20260112185908.png" loading=lazy src=/blogs/media/pasted-image-20260112185908.png>
We can configure VLAN at the end hosts or at the bridge itself, where bridge will store the mapping for a port and corresponding <code>vlan-id</code>.
If we look at the currently configured <code>vlan-id</code> at the bridge:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>laborant@ubuntu-01:~$ bridge vlan
</span></span><span class=line><span class=ln>2</span><span class=cl>port              vlan-id
</span></span><span class=line><span class=ln>3</span><span class=cl>veth1             <span class=m>1</span> PVID Egress Untagged
</span></span><span class=line><span class=ln>4</span><span class=cl>veth2             <span class=m>1</span> PVID Egress Untagged
</span></span><span class=line><span class=ln>5</span><span class=cl>veth3             <span class=m>1</span> PVID Egress Untagged
</span></span><span class=line><span class=ln>6</span><span class=cl>veth4             <span class=m>1</span> PVID Egress Untagged
</span></span><span class=line><span class=ln>7</span><span class=cl>veth5             <span class=m>1</span> PVID Egress Untagged
</span></span><span class=line><span class=ln>8</span><span class=cl>veth6             <span class=m>1</span> PVID Egress Untagged
</span></span><span class=line><span class=ln>9</span><span class=cl>br0               <span class=m>1</span> PVID Egress Untagged
</span></span></code></pre></div><p>Each of the port is configured with <code>vlan-id</code> 1 and is configured <code>Untagged</code> for egress traffic, That means bridge will not tag the outgoing traffic with the <code>VLAN ID = 1</code> in ethernet frame (as shown above) which is fine since currently all the ports have same <code>vlan-id</code>.</p><p>Lets configure the bridge to have <code>vlan-id = 10</code> for <code>192.168.0.0/24</code> subnet and <code>vlan-id = 20</code> for <code>192.168.1.0/24</code> subnet.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln> 1</span><span class=cl><span class=c1># Removing exisiting vid 1 from all ports</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan del dev veth1 vid <span class=m>1</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan del dev veth2 vid <span class=m>1</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan del dev veth3 vid <span class=m>1</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan del dev veth4 vid <span class=m>1</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan del dev veth5 vid <span class=m>1</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan del dev veth6 vid <span class=m>1</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1># Adding new VIDs per subnet</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan add dev veth1 vid <span class=m>10</span> pvid <span class=m>10</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan add dev veth2 vid <span class=m>10</span> pvid <span class=m>10</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan add dev veth3 vid <span class=m>10</span> pvid <span class=m>10</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan add dev veth4 vid <span class=m>20</span> pvid <span class=m>20</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan add dev veth5 vid <span class=m>20</span> pvid <span class=m>20</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>laborant@ubuntu-01:~$ sudo bridge vlan add dev veth6 vid <span class=m>20</span> pvid <span class=m>20</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>
</span></span><span class=line><span class=ln>17</span><span class=cl><span class=c1># Enable VLAN filtering on bridge br0</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>laborant@ubuntu-01:networking$ sudo ip link <span class=nb>set</span> br0 <span class=nb>type</span> bridge vlan_filtering <span class=m>1</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>
</span></span><span class=line><span class=ln>20</span><span class=cl><span class=c1># New bridge config</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>laborant@ubuntu-01:~$ bridge vlan
</span></span><span class=line><span class=ln>22</span><span class=cl>port              vlan-id
</span></span><span class=line><span class=ln>23</span><span class=cl>veth1             <span class=m>10</span> PVID
</span></span><span class=line><span class=ln>24</span><span class=cl>veth2             <span class=m>10</span> PVID
</span></span><span class=line><span class=ln>25</span><span class=cl>veth3             <span class=m>10</span> PVID
</span></span><span class=line><span class=ln>26</span><span class=cl>veth4             <span class=m>20</span> PVID
</span></span><span class=line><span class=ln>27</span><span class=cl>veth5             <span class=m>20</span> PVID
</span></span><span class=line><span class=ln>28</span><span class=cl>veth6             <span class=m>20</span> PVID
</span></span><span class=line><span class=ln>29</span><span class=cl>br0               <span class=m>1</span> PVID Egress Untagged
</span></span></code></pre></div><p>Now lets try to send a broadcast message from <code>ceth4</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>laborant@ubuntu-01:networking$ sudo ip netns <span class=nb>exec</span> ns4 /home/laborant/networking/l2_send ceth4 ff:ff:ff:ff:ff:ff
</span></span><span class=line><span class=ln>2</span><span class=cl>Sent Ethernet frame via ceth4 → ff:ff:ff:ff:ff:ff
</span></span></code></pre></div><p>All interfaces of <code>vlan=20</code> heard the broadcast whereas no traffic reached interfaces <code>ceth1, ceth2 and ceth3</code> of <code>vlan=10</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth5 -e -n
</span></span><span class=line><span class=ln>2</span><span class=cl>16:15:09.042913 1a:cc:a5:0b:b3:52 &gt; ff:ff:ff:ff:ff:ff, ethertype Unknown <span class=o>(</span>0x88b5<span class=o>)</span>, length 29:
</span></span><span class=line><span class=ln>3</span><span class=cl>        0x0000:  4c32 2d74 <span class=m>6573</span> 742d <span class=m>6672</span> 6f6d 2d67 6f    L2-test-from-go
</span></span><span class=line><span class=ln>4</span><span class=cl>
</span></span><span class=line><span class=ln>5</span><span class=cl>
</span></span><span class=line><span class=ln>6</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth6 -e -n
</span></span><span class=line><span class=ln>7</span><span class=cl>16:15:09.042913 1a:cc:a5:0b:b3:52 &gt; ff:ff:ff:ff:ff:ff, ethertype Unknown <span class=o>(</span>0x88b5<span class=o>)</span>, length 29:
</span></span><span class=line><span class=ln>8</span><span class=cl>        0x0000:  4c32 2d74 <span class=m>6573</span> 742d <span class=m>6672</span> 6f6d 2d67 6f    L2-test-from-go
</span></span></code></pre></div><p>Likewise, when <code>192.168.1.1</code> pings <code>192.168.1.3</code>, the ARP request to resolve <code>192.168.1.3</code>&rsquo;s MAC address is exclusively broadcast to interfaces within the <code>192.168.1.1</code> subnet that belong to VLAN 20. This illustrates how VLANs contribute to separating traffic between subnets.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth5 -e -n
</span></span><span class=line><span class=ln>2</span><span class=cl>16:25:25.134826 1a:cc:a5:0b:b3:52 &gt; ff:ff:ff:ff:ff:ff, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>, length 42: Request who-has 192.168.1.3 tell 192.168.1.1, length <span class=m>28</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>
</span></span><span class=line><span class=ln>4</span><span class=cl>
</span></span><span class=line><span class=ln>5</span><span class=cl>root@ubuntu-01:laborant# tcpdump -i ceth6 -e -n
</span></span><span class=line><span class=ln>6</span><span class=cl>16:25:25.134838 1a:cc:a5:0b:b3:52 &gt; ff:ff:ff:ff:ff:ff, ethertype 802.1Q <span class=o>(</span>0x8100<span class=o>)</span>, length 46: vlan 20, p 0, ethertype ARP <span class=o>(</span>0x0806<span class=o>)</span>, Request who-has 192.168.1.3 tell 192.168.1.1, length <span class=m>28</span>
</span></span></code></pre></div><p>Following diagram shows how VLAN separates traffic of two subnets by enabling VLAN filtering at the bridge level.
<img alt="Pasted image 20260112220530.png" loading=lazy src=/blogs/media/pasted-image-20260112220530.png></p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In this post, we explored how <strong>L1, L2, and L3 network segments</strong> are formed and how the different layers of the <strong>OSI model</strong> work together in practice using Linux network namespaces. We began with pure Layer 2 communication using MAC addresses, examined broadcast domains and MAC learning behavior in a bridge, and then built on top of that to understand Layer 3 communication using IP and ARP. Through packet captures, we clearly saw how ARP bridges the gap between IP addressing and Ethernet, and how broadcast domains define the scope of Layer 2 visibility. Finally, by introducing VLANs, we demonstrated how broadcast domains can be cleanly partitioned within a single Layer 2 infrastructure, reinforcing the separation between Layer 2 forwarding and Layer 3 addressing while still allowing scalable and structured network designs.</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><p><a href=https://labs.iximiuz.com/courses/computer-networking-fundamentals>https://labs.iximiuz.com/courses/computer-networking-fundamentals</a> - A great place to experiment with contents of this blog. This blog post is inspired from the course itself - Highly recommended.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://harshrai654.github.io/blogs/debugging-http-503-uc-errors-in-istio-service-mesh/><span class=title>« Prev</span><br><span>Debugging HTTP 503 UC Errors in Istio Service Mesh</span>
</a><a class=next href=https://harshrai654.github.io/blogs/multipart-form-uploads---busboy-and-node-streams/><span class=title>Next »</span><br><span>Multipart Form Uploads - Busboy and Node Streams</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Networking Basics on x" href="https://x.com/intent/tweet/?text=Networking%20Basics&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2fnetworking-basics%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Networking Basics on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2fnetworking-basics%2f&amp;title=Networking%20Basics&amp;summary=Networking%20Basics&amp;source=https%3a%2f%2fharshrai654.github.io%2fblogs%2fnetworking-basics%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Networking Basics on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fharshrai654.github.io%2fblogs%2fnetworking-basics%2f&title=Networking%20Basics"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Networking Basics on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fharshrai654.github.io%2fblogs%2fnetworking-basics%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Networking Basics on whatsapp" href="https://api.whatsapp.com/send?text=Networking%20Basics%20-%20https%3a%2f%2fharshrai654.github.io%2fblogs%2fnetworking-basics%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Networking Basics on telegram" href="https://telegram.me/share/url?text=Networking%20Basics&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2fnetworking-basics%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Networking Basics on ycombinator" href="https://news.ycombinator.com/submitlink?t=Networking%20Basics&u=https%3a%2f%2fharshrai654.github.io%2fblogs%2fnetworking-basics%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://harshrai654.github.io/blogs/>Learning Loop</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";

  
  function isDarkMode() {
    return (
      document.body.classList.contains("dark") ||
      localStorage.getItem("pref-theme") === "dark" ||
      (!localStorage.getItem("pref-theme") &&
        window.matchMedia("(prefers-color-scheme: dark)").matches)
    );
  }

  
  mermaid.initialize({
    startOnLoad: true,
    theme: isDarkMode() ? "dark" : "default",
    themeVariables: {
      dark: {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#ffffff",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#ffffff",
        secondaryColor: "#4ecdc4",
        tertiaryColor: "#45b7d1",
        background: "#1a1a1a",
        mainBkg: "#2d2d2d",
        secondBkg: "#3d3d3d",
        tertiaryBkg: "#4d4d4d",
      },
      default: {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#000000",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#000000",
        secondaryColor: "#4ecdc4",
        tertiaryColor: "#45b7d1",
      },
    },
  });

  
  const themeToggle = document.getElementById("theme-toggle");
  if (themeToggle) {
    themeToggle.addEventListener("click", () => {
      setTimeout(() => {
        mermaid.initialize({
          startOnLoad: false,
          theme: isDarkMode() ? "dark" : "default",
          themeVariables: {
            dark: {
              primaryColor: "#ff6b6b",
              primaryTextColor: "#ffffff",
              primaryBorderColor: "#ff6b6b",
              lineColor: "#ffffff",
              secondaryColor: "#4ecdc4",
              tertiaryColor: "#45b7d1",
              background: "#1a1a1a",
              mainBkg: "#2d2d2d",
              secondBkg: "#3d3d3d",
              tertiaryBkg: "#4d4d4d",
            },
            default: {
              primaryColor: "#ff6b6b",
              primaryTextColor: "#000000",
              primaryBorderColor: "#ff6b6b",
              lineColor: "#000000",
              secondaryColor: "#4ecdc4",
              tertiaryColor: "#45b7d1",
            },
          },
        });

        
        document.querySelectorAll(".mermaid").forEach((element) => {
          element.removeAttribute("data-processed");
          mermaid.init(undefined, element);
        });
      }, 100);
    });
  }
</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>