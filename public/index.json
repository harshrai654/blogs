[{"content":"Files and directories File systems virtualize persistent storage (e.g., hard drives, SSDs) into user-friendly files and directories, adding a third pillar to OS abstractions (processes for CPU, address spaces for memory).\nFile Paths and System Calls Files are organized in a tree-like directory structure, starting from the root (/). A file’s location is identified by its pathname (e.g., /home/user/file.txt). To interact with files, processes use system calls:\nopen(path, flags): Opens a file and returns a file descriptor (fd). read(fd, buffer, size): Reads data from the file into a buffer using the fd. write(fd, buffer, size): Writes data to the file via the fd. close(fd): Closes the file, freeing the fd. File Descriptors A file descriptor is a small integer, unique to each process, that identifies an open file. When a process calls open(), the operating system assigns it the next available fd (e.g., 3, 4, etc.). Every process starts with three default fds:\n0: Standard input (stdin) 1: Standard output (stdout) 2: Standard error (stderr) Quick Note: File Descriptors \u0026amp; Terminals Every process starts with three standard file descriptors:\n0 (stdin), 1 (stdout), 2 (stderr). Where They Point By default they link to a terminal device (e.g., /dev/pts/0 for Terminal 1, /dev/pts/1 for Terminal 2). These are character devices with a major number (e.g., 136) for the tty driver and a unique minor number (e.g., 0 or 1) for each instance.\nCommand Output (Terminal 1):\nls -l /proc/self/fd lrwx------ 1 runner runner 64 Feb 23 11:47 0 -\u0026gt; /dev/pts/0 lrwx------ 1 runner runner 64 Feb 23 11:47 1 -\u0026gt; /dev/pts/0 lrwx------ 1 runner runner 64 Feb 23 11:47 2 -\u0026gt; /dev/pts/0 Device Details:\nls -l /dev/pts/0 crw--w---- 1 runner tty 136, 0 Feb 23 11:53 /dev/pts/0 ~/workspace$ stat /dev/pts/0 File: /dev/pts/0 Size: 0 Blocks: 0 IO Block: 1024 character special file Device: 0,1350 Inode: 3 Links: 1 Device type: 136,0 Access: (0620/crw--w----) Uid: ( 1000/ runner) Gid: ( 5/ tty) Access: 2025-02-23 12:13:52.419852946 +0000 Modify: 2025-02-23 12:13:52.419852946 +0000 Change: 2025-02-23 11:36:28.419852946 +0000 Birth: - Versus a File A regular file descriptor (e.g., for test.txt) points to a disk inode with data blocks, tied to a filesystem device (e.g., /dev/sda1), not a driver.\nExample:\nls -li test.txt 12345 -rw-r--r-- 1 runner runner 5 Feb 23 12:00 test.txt ~/workspace$ stat test.txt File: test.txt Size: 288 Blocks: 8 IO Block: 4096 regular file Device: 0,375 Inode: 1111 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 1000/ runner) Gid: ( 1000/ runner) Access: 2025-02-23 11:40:57.014322027 +0000 Modify: 2025-02-23 11:41:41.800233516 +0000 Change: 2025-02-23 11:41:41.800233516 +0000 Birth: 2025-02-23 11:40:57.014322027 +0000 Fun Test Redirected Terminal 1’s output to Terminal 2:\nCommand: echo \u0026quot;Hello\u0026quot; \u0026gt; /dev/pts/1 Result: \u0026ldquo;Hello\u0026rdquo; appeared in Terminal 2 (/dev/pts/1, minor 1)! Open File Table The Open File Table (OFT) is a system-wide structure in kernel memory that tracks all open files. Each entry in the OFT includes:\nThe current offset (position for the next read/write). Permissions (e.g., read, write). A reference count (if multiple processes share the file). Each process has its own array of file descriptors, where each fd maps to an entry in the OFT. For example, process A’s fd 3 and process B’s fd 4 might point to the same OFT entry if they’ve opened the same file.\nExample: Showing entries of a PID in open file table\n~/workspace$ lsof -p 113 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME bash 113 runner cwd DIR 0,375 394 256 /home/runner/workspace bash 113 runner rtd DIR 0,1324 4096 1562007 / bash 113 runner 0u CHR 136,0 0t0 3 /dev/pts/0 bash 113 runner 1u CHR 136,0 0t0 3 /dev/pts/0 bash 113 runner 2u CHR 136,0 0t0 3 /dev/pts/0 bash 113 runner 255u CHR 136,0 0t0 3 /dev/pts/0 As you see above that the process had 0,1 and 2 FDs as well as FD for a directory as well.\nReference counting in OFT Reference counting is a technique used in operating systems to manage entries in the Open File Table (OFT), which stores information about open files shared by processes or file descriptors.\nHow It Works Each OFT entry has a reference count that tracks how many file descriptors (from one or more processes) refer to it. When a file is opened, the reference count increases by 1. If the same file is reused (e.g., via fork() or dup()), the count increments without creating a new entry. When a file descriptor is closed (e.g., with close(fd)), the count decreases by 1. The OFT entry is removed only when the reference count reaches 0, meaning no process is using it. How It Helps Remove Entries Reference counting ensures an OFT entry is deleted only when it’s no longer needed. For example, after a fork(), both parent and child processes share the same OFT entry (reference count = 2). Closing the file in one process lowers the count to 1, but the entry persists until the second process closes it, bringing the count to 0.\nWhy It’s Useful This method efficiently manages shared file resources, preventing premature removal of file metadata (like the current offset) while any process still needs it.\nINode What is an Inode? An inode (short for \u0026ldquo;index node\u0026rdquo;) is a fundamental data structure in UNIX-based file systems. It stores essential metadata about a file, enabling the system to manage and locate files efficiently. Each file in the system is uniquely identified by its inode number (also called i-number). The metadata stored in an inode includes:\nFile size: The total size of the file in bytes.\nPermissions: Access rights defining who can read, write, or execute the file.\nOwnership: User ID (UID) and group ID (GID) of the file\u0026rsquo;s owner.\nTimestamps:\nLast access time (when the file was last read). Last modification time (when the file\u0026rsquo;s content was last changed). Last status change time (when the file\u0026rsquo;s metadata, like permissions, was last modified). Pointers to data blocks: Locations on disk where the file\u0026rsquo;s actual content is stored.\nThe inode does not store the file\u0026rsquo;s name or its content; these are managed separately. The inode\u0026rsquo;s role is to provide a compact and efficient way to access a file\u0026rsquo;s metadata. Each inode is stored in inode block in disk.\nHow the stat System Call Works The stat system call is used to retrieve metadata about a file without accessing its actual content. It provides a way for programs to query information like file size, permissions, and timestamps. Here\u0026rsquo;s how it works:\nInput: The stat system call takes a file path as input. Locate the inode: The file system uses the file path to find the corresponding inode number. (Insert link to FS implemetation note here explaining how FS searches inode and data block from given file path) Retrieve metadata: The inode is fetched from disk (or from a cache, if available, for faster access). Populate the struct stat buffer: The metadata stored in the inode is copied into a struct stat buffer, which contains fields for file size, permissions, ownership, timestamps, and more. Return to the user: The struct stat buffer is returned to the calling program, providing all the metadata for the file. Because the stat system call only accesses the inode and not the file\u0026rsquo;s content, it is a fast and efficient operation. This separation of metadata (stored in the inode) and content (stored in data blocks) allows the system to quickly retrieve file information without unnecessary disk I/O.\nDirectories ls -al Output for Directories\ntotal 152 drwxr-xr-x 1 runner runner 394 Feb 23 11:40 . drwxrwxrwx 1 runner runner 46 Feb 23 11:36 .. -rw-r--r-- 1 runner runner 174 Feb 15 11:31 .breakpoints drwxr-xr-x 1 runner runner 34 Feb 15 11:32 .cache drwxr-x--- 1 runner runner 260 Feb 15 11:31 .ccls-cache -rw-r--r-- 1 runner runner 1564 Dec 21 11:44 common_threads.h -rwxr-xr-x 1 runner runner 16128 Dec 21 11:54 deadlock -rw-r--r-- 1 runner runner 647 Dec 21 11:51 deadlock.c -rwxr-xr-x 1 runner runner 16160 Dec 21 11:57 deadlock-global -rw-r--r-- 1 runner runner 748 Dec 21 11:57 deadlock-global.c -rw-r--r-- 1 runner runner 6320 Feb 23 11:36 generated-icon.png -rw-r--r-- 1 runner runner 429 Mar 8 2024 .gitignore -rwxr-xr-x 1 runner runner 15984 Dec 21 11:51 main -rw-r--r-- 1 runner runner 415 Dec 21 11:51 main.c -rwxr-xr-x 1 runner runner 16816 Aug 16 2024 main-debug -rw-r--r-- 1 runner runner 411 Dec 12 2023 Makefile -rwxr-xr-x 1 runner runner 16136 Dec 14 11:04 mem -rw-r--r-- 1 runner runner 1437 Aug 16 2024 .replit -rw-r--r-- 1 runner runner 134 Feb 23 13:54 replit.nix -rwxr-xr-x 1 runner runner 15936 Dec 21 11:59 signal -rw-r--r-- 1 runner runner 329 Dec 21 11:59 signal.c -rw-r--r-- 1 runner runner 288 Feb 23 11:41 test.txt drwxr-xr-x 1 runner runner 42 Feb 15 11:32 wcat Size of a directory only means storage needed to store each directory entry which basically comprise entry name and its inode number along with some other metdata\nDirectory Data Block Contents The data blocks of a directory contain:\nDirectory entries: Mapping of file/subdirectory names to their inode numbers. Special entries: . (current directory) and .. (parent directory). Optimization for Small Directories For small directories, some file systems store directory entries directly in the inode itself, avoiding separate data blocks. This optimization saves space and speeds up access.\nReading Directory Entries with System Calls To programmatically read directory contents following sys calls are used:\nopendir(path): Opens the directory. readdir(dir): Reads one entry at a time (returns a struct dirent with name and inode number. closedir(dir): Closes the directory. Permission bits and their octal representation Format: ls -l displays permissions as rwxr-xr-x:\nFirst character: d (directory), - (file), or l (symlink). Next 9 bits: Three groups of rwx for owner, group, and others: r = read, w = write, x = execute (run for files, enter for directories). Converting a Full 9-Bit Permission to Numeric (Octal) Representation Example: rwxr-xr-x\nBreakdown: Split into three groups (owner, group, others): Owner: rwx. Group: r-x. Others: r-x. Step-by-Step Conversion\nOwner: rwx: r = 1, w = 1, x = 1 → Binary: 111. Decimal: 1×4 + 1×2 + 1×1 = 4 + 2 + 1 = 7. Group: r-x: r = 1, w = 0, x = 1 → Binary: 101. Decimal: 1×4 + 0×2 + 1×1 = 4 + 1 = 5. Others: r-x: r = 1, w = 0, x = 1 → Binary: 101. Decimal: 1×4 + 0×2 + 1×1 = 4 + 1 = 5. Final Octal Representation\nCombine the three digits: 7 5 5. Result: rwxr-xr-x = 755. Quick Recall: Split rwx into 3 groups, convert each to binary (1s/0s), sum (4, 2, 1), get octal (e.g., 755). Hard Links, Symbolic Links (Including Size), and File Deletion (Based on OSTEP PDF) Hard Links and unlink Definition: A hard link (PDF p. 18-19) is an extra directory entry pointing to the same inode, created with link(old, new).. When a directory reference its parent directory (with ..) it increases hard link count by 1. For a new empty directory its hard count is always 2 since it is referred by itself (with .) and also referred by its parent\u0026rsquo;s directory entry (with ..) With unlink: Removes a name-to-inode link, decrements the inode’s link count. When count hits 0 (and no processes use it), the inode and data blocks are freed from disk. Symbolic Links and Dangling References Definition: A symbolic (soft) link (PDF p. 20-21) is a distinct file storing a pathname to another file, created with ln -s old new. Size: Its size equals the length of the stored pathname (e.g., 4 bytes for \u0026ldquo;file\u0026rdquo;, 15 bytes for \u0026ldquo;alongerfilename\u0026rdquo;; PDF p. 21). How It Works: References the path, not the inode directly; accessing it resolves the path. Dangling Reference: If the target is deleted (e.g., unlink file), the symbolic link persists but points to nothing, causing errors (e.g., \u0026ldquo;No such file or directory\u0026rdquo;). Disk, Partition, Volume, File System Hierarchy, and Mounting Distinction and Hierarchy Disk: Physical storage device (e.g., hard drive, SSD) holding raw data blocks. Partition: A subdivided section of a disk (e.g., /dev/sda1), treated as a separate unit. Volume: A logical abstraction, often a partition or group of partitions, formatted with a file system (FS). File System: Software structure (e.g., ext3, AFS) organizing data into files and directories on a volume. Hierarchy: Disk → Partitions → Volumes → File Systems.\nMounting Process Creation: Use mkfs to format a partition with a file system (e.g., mkfs -t ext3 /dev/sda1 creates an empty FS). Mounting: The mount command (PDF p. 24) attaches a file system to the directory tree at a mount point (e.g., mount -t ext3 /dev/sda1 /home/users), making its contents accessible under that path. Multiple File Systems on One Machine A single machine can host multiple file systems by mounting them at different points in the tree (PDF p. 26). Example Output (from mount): /dev/sda1 on / type ext3 (rw) # Root FS /dev/sda5 on /tmp type ext3 (rw) # Separate tmp FS AFS on /afs type afs (rw) # Distributed FS How: Each partition or volume gets its own FS type and mount point, unified under one tree (e.g., /). Quick Recall: Disk splits into partitions; volumes get FS; mount glues them into a tree; multiple FS coexist at different paths.\nReferences https://pages.cs.wisc.edu/~remzi/OSTEP/file-intro.pdf https://grok.com/share/bGVnYWN5_47ab49d6-aa1d-4de1-9bbe-0d47332e12fe https://grok.com/share/bGVnYWN5_7db77c97-d33d-4543-9993-d5aa362c8b2b ","permalink":"http://localhost:1313/blogs/files-and-directories/","summary":"\u003ch1 id=\"files-and-directories\"\u003eFiles and directories\u003c/h1\u003e\n\u003cp\u003eFile systems virtualize persistent storage (e.g., hard drives, SSDs) into user-friendly files and directories, adding a third pillar to OS abstractions (processes for CPU, address spaces for memory).\u003c/p\u003e\n\u003ch2 id=\"file-paths-and-system-calls\"\u003eFile Paths and System Calls\u003c/h2\u003e\n\u003cp\u003eFiles are organized in a \u003cstrong\u003etree-like directory structure\u003c/strong\u003e, starting from the root (/). A file’s location is identified by its \u003cstrong\u003epathname\u003c/strong\u003e (e.g., /home/user/file.txt). To interact with files, processes use \u003cstrong\u003esystem calls\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eopen(path, flags)\u003c/strong\u003e: Opens a file and returns a \u003cstrong\u003efile descriptor\u003c/strong\u003e (fd).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eread(fd, buffer, size)\u003c/strong\u003e: Reads data from the file into a buffer using the fd.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewrite(fd, buffer, size)\u003c/strong\u003e: Writes data to the file via the fd.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eclose(fd)\u003c/strong\u003e: Closes the file, freeing the fd.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"file-descriptors\"\u003eFile Descriptors\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003efile descriptor\u003c/strong\u003e is a small integer, unique to each process, that identifies an open file. When a process calls open(), the operating system assigns it the next available fd (e.g., 3, 4, etc.). Every process starts with three default fds:\u003c/p\u003e","title":"Files And Directories"},{"content":"Overall Organization Of Data In Disks Assuming we have a 256KB disk.\nDisk Blocks: The basic units of storage on the disk, each 4 KB in size. The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks). Inode Bitmap (i): Block 1; a bitmap tracking which inodes are free (0) or in-use (1). Data Bitmap (d): Block 2; a bitmap tracking which data blocks are free (0) or allocated (1). Inode Table (I): Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks. 5 blocks of 4KB will contain 80 256 byte inode strutures. Data Region (D): Blocks 8-63; the largest section, storing the actual contents of files and directories. Inode Every inode has a unique identifier called an inode number (or i-number). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:\nIn a system with 80 inodes, numbers might range from 0 to 79. Conventionally, the root directory is assigned inode number 2 (numbers 0 and 1 are often reserved or used for special purposes). The inode number is the key to finding a file’s metadata on the disk, and it’s stored in directory entries alongside the file’s name.\nHow Do We Jump to the Disk Block for a Specific Inode Number? In a file system like vsfs, inodes are stored consecutively in an inode table, a reserved area of the disk (e.g., spanning blocks 3 to 7). Each inode has a fixed size—let’s say 256 bytes—and the disk is divided into blocks (e.g., 4096 bytes each). To locate a specific inode given its i-number, we calculate its exact position on the disk. Here’s how:\nIdentify the Inode Table’s Starting Block: Suppose the inode table starts at block 3. Calculate the Block Containing the Inode: Formula: block = (i-number * inode_size) / block_size + start_block Example: For inode 10, inode_size = 256 bytes, block_size = 4096 bytes, start_block = 3 (10 * 256) / 4096 = 2560 / 4096 = 0.625 → integer part is 0. block = 0 + 3 = 3. So, inode 10 is in block 3. Calculate the Offset Within the Block: Formula: offset = (i-number * inode_size) % block_size Example: (10 * 256) % 4096 = 2560 % 4096 = 2560 bytes. Inode 10 starts 2560 bytes into block 3. Result: The operating system reads block 3 from the disk and jumps to offset 2560 bytes to access inode 10’s metadata. This process allows the file system to efficiently retrieve an inode’s information and, from there, its data blocks. Since multiple processes may have file descriptors for the same file opened with their own data of offset to read from, multiple processes will be accessing the same inode structure to read about file and modify its data (Here inodes data would mean modifying things like last accessed time or adding another entry for list of data blocks etc), So i-node needs some sort of concurrency control in place. (More on this)\nHow does inode know the data it owns An inode is a data structure in a file system that stores information about a file, including where its data is located on the disk. Instead of holding the file’s data itself, the inode contains pointers that reference the disk blocks where the data is stored.\nDisk Blocks: These are fixed-size chunks of storage on the disk (e.g., 4 KB each) that hold the actual file content. Pointers: These are entries in the inode that specify the locations of these disk blocks. The inode uses these pointers to keep track of all the blocks that make up a file, allowing the file system to retrieve the data when needed.\nWhat Are Disk Addresses? Disk addresses are the identifiers that tell the file system the exact physical locations of data blocks on the disk. Think of them as a map: each address corresponds to a specific block, such as block number 100, which might map to a particular sector and track on a hard drive.\nFor example, if a file is 8 KB and the block size is 4 KB, the inode might have two pointers with disk addresses like \u0026ldquo;block 50\u0026rdquo; and \u0026ldquo;block 51,\u0026rdquo; pointing to the two blocks that hold the file’s data. How Does an Inode Manage Disk Blocks? The inode organizes its pointers in a way that can handle files of different sizes efficiently. It uses a combination of direct pointers and indirect pointers, forming a multi-level indexing structure.\n1. Direct Pointers The inode starts with a set of direct pointers, which point straight to the disk addresses of data blocks. Example: If the block size is 4 KB and the inode has 12 direct pointers, it can directly address 12 × 4 KB = 48 KB of data. 2. Indirect Pointers (Multi-Level Indexing) For files too big for direct pointers alone, the inode uses indirect pointers, which point to special blocks that themselves contain more pointers. This creates a hierarchical, or multi-level, structure.\nSingle Indirect Pointer\nThis pointer points to a block (called an indirect block) that contains a list of disk addresses to data blocks.\nExample: If a block is 4 KB and each pointer is 4 bytes, the indirect block can hold 4 KB / 4 bytes = 1024 pointers. That’s 1024 × 4 KB = 4 MB of additional data.\nTotal with Direct: With 12 direct pointers and 1 single indirect pointer, the file can reach (12 + 1024) × 4 KB = 4,096 KB (about 4 MB).\nDouble Indirect Pointer\nThis pointer points to a block that contains pointers to other single indirect blocks, each of which points to data blocks.\nExample: The double indirect block might hold 1024 pointers to single indirect blocks. Each of those holds 1024 pointers to data blocks, so that’s 1024 × 1024 = 1,048,576 data blocks, or about 4 GB with 4 KB blocks.\nTotal with Direct and Single: (12 + 1024 + 1,048,576) × 4 KB ≈ 4 GB.\nThis structure acts like an imbalanced tree: small files use only direct pointers, while larger files use additional levels of indirection as needed.\nWhy Use Multi-Level Indexing? The multi-level indexing structure is designed to balance efficiency and scalability:\nSmall Files: Most files are small, so direct pointers handle them quickly without extra overhead. Large Files: Indirect pointers allow the inode to scale up to support massive files by adding more layers of pointers. How It Works in Practice When the file system needs to find a specific block in a file:\nIt checks the inode’s direct pointers first. If the block number is beyond the direct pointers’ range, it follows the single indirect pointer to the indirect block and looks up the address there. For even larger block numbers, it traverses the double indirect or triple indirect pointers, following the hierarchy until it finds the right disk address. This process ensures the file system can efficiently locate any block, no matter how big the file is.\nReferences https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf https://grok.com/chat/d429de0e-556f-426c-84bd-21ff1b0c4002 (Contains reference to actual inode structure implementation along with locks it uses on Linux) https://grok.com/chat/c86e3040-2f86-4aa9-a317-1c0a464564a3?referrer=website ","permalink":"http://localhost:1313/blogs/file-system-implementation/","summary":"\u003ch2 id=\"overall-organization-of-data-in-disks\"\u003eOverall Organization Of Data In Disks\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eAssuming we have a 256KB disk\u003c/em\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDisk Blocks\u003c/strong\u003e: The basic units of storage on the disk, \u003cem\u003eeach 4 KB in size.\u003c/em\u003e The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInode Bitmap (i)\u003c/strong\u003e: Block 1; a bitmap tracking which inodes are free (0) or in-use (1).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eData Bitmap (d)\u003c/strong\u003e: Block 2; a bitmap tracking which data blocks are free (0) or allocated (1).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInode Table (I)\u003c/strong\u003e: Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks.\n5 blocks of 4KB will contain 80 256 byte inode strutures.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eData Region (D)\u003c/strong\u003e: Blocks 8-63; the largest section, storing the actual contents of files and directories.\n\u003cimg alt=\"Pasted image 20250301204506.png\" loading=\"lazy\" src=\"/blogs/media/pasted-image-20250301204506.png\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"inode\"\u003eInode\u003c/h2\u003e\n\u003cp\u003eEvery inode has a unique identifier called an \u003cstrong\u003einode number\u003c/strong\u003e (or \u003cstrong\u003ei-number\u003c/strong\u003e). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:\u003c/p\u003e","title":"Understanding Inodes and Disk Layout"},{"content":"Overall Organization Of Data In Disks Assuming we have a 256KB disk.\nDisk Blocks: The basic units of storage on the disk, each 4 KB in size. The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks). Inode Bitmap (i): Block 1; a bitmap tracking which inodes are free (0) or in-use (1). Data Bitmap (d): Block 2; a bitmap tracking which data blocks are free (0) or allocated (1). Inode Table (I): Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks. 5 blocks of 4KB will contain 80 256 byte inode strutures. Data Region (D): Blocks 8-63; the largest section, storing the actual contents of files and directories. Inode Every inode has a unique identifier called an inode number (or i-number). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:\nIn a system with 80 inodes, numbers might range from 0 to 79. Conventionally, the root directory is assigned inode number 2 (numbers 0 and 1 are often reserved or used for special purposes). The inode number is the key to finding a file’s metadata on the disk, and it’s stored in directory entries alongside the file’s name.\nHow Do We Jump to the Disk Block for a Specific Inode Number? In a file system like vsfs, inodes are stored consecutively in an inode table, a reserved area of the disk (e.g., spanning blocks 3 to 7). Each inode has a fixed size—let’s say 256 bytes—and the disk is divided into blocks (e.g., 4096 bytes each). To locate a specific inode given its i-number, we calculate its exact position on the disk. Here’s how:\nIdentify the Inode Table’s Starting Block: Suppose the inode table starts at block 3. Calculate the Block Containing the Inode: Formula: block = (i-number * inode_size) / block_size + start_block Example: For inode 10, inode_size = 256 bytes, block_size = 4096 bytes, start_block = 3 (10 * 256) / 4096 = 2560 / 4096 = 0.625 → integer part is 0. block = 0 + 3 = 3. So, inode 10 is in block 3. Calculate the Offset Within the Block: Formula: offset = (i-number * inode_size) % block_size Example: (10 * 256) % 4096 = 2560 % 4096 = 2560 bytes. Inode 10 starts 2560 bytes into block 3. Result: The operating system reads block 3 from the disk and jumps to offset 2560 bytes to access inode 10’s metadata. This process allows the file system to efficiently retrieve an inode’s information and, from there, its data blocks. Since multiple processes may have file descriptors for the same file opened with their own data of offset to read from, multiple processes will be accessing the same inode structure to read about file and modify its data (Here inodes data would mean modifying things like last accessed time or adding another entry for list of data blocks etc), So i-node needs some sort of concurrency control in place. (More on this)\nHow does inode know the data it owns An inode is a data structure in a file system that stores information about a file, including where its data is located on the disk. Instead of holding the file’s data itself, the inode contains pointers that reference the disk blocks where the data is stored.\nDisk Blocks: These are fixed-size chunks of storage on the disk (e.g., 4 KB each) that hold the actual file content. Pointers: These are entries in the inode that specify the locations of these disk blocks. The inode uses these pointers to keep track of all the blocks that make up a file, allowing the file system to retrieve the data when needed.\nWhat Are Disk Addresses? Disk addresses are the identifiers that tell the file system the exact physical locations of data blocks on the disk. Think of them as a map: each address corresponds to a specific block, such as block number 100, which might map to a particular sector and track on a hard drive.\nFor example, if a file is 8 KB and the block size is 4 KB, the inode might have two pointers with disk addresses like \u0026ldquo;block 50\u0026rdquo; and \u0026ldquo;block 51,\u0026rdquo; pointing to the two blocks that hold the file’s data. How Does an Inode Manage Disk Blocks? The inode organizes its pointers in a way that can handle files of different sizes efficiently. It uses a combination of direct pointers and indirect pointers, forming a multi-level indexing structure.\n1. Direct Pointers The inode starts with a set of direct pointers, which point straight to the disk addresses of data blocks. Example: If the block size is 4 KB and the inode has 12 direct pointers, it can directly address 12 × 4 KB = 48 KB of data. 2. Indirect Pointers (Multi-Level Indexing) For files too big for direct pointers alone, the inode uses indirect pointers, which point to special blocks that themselves contain more pointers. This creates a hierarchical, or multi-level, structure.\nSingle Indirect Pointer\nThis pointer points to a block (called an indirect block) that contains a list of disk addresses to data blocks.\nExample: If a block is 4 KB and each pointer is 4 bytes, the indirect block can hold 4 KB / 4 bytes = 1024 pointers. That’s 1024 × 4 KB = 4 MB of additional data.\nTotal with Direct: With 12 direct pointers and 1 single indirect pointer, the file can reach (12 + 1024) × 4 KB = 4,096 KB (about 4 MB).\nDouble Indirect Pointer\nThis pointer points to a block that contains pointers to other single indirect blocks, each of which points to data blocks.\nExample: The double indirect block might hold 1024 pointers to single indirect blocks. Each of those holds 1024 pointers to data blocks, so that’s 1024 × 1024 = 1,048,576 data blocks, or about 4 GB with 4 KB blocks.\nTotal with Direct and Single: (12 + 1024 + 1,048,576) × 4 KB ≈ 4 GB.\nThis structure acts like an imbalanced tree: small files use only direct pointers, while larger files use additional levels of indirection as needed.\nWhy Use Multi-Level Indexing? The multi-level indexing structure is designed to balance efficiency and scalability:\nSmall Files: Most files are small, so direct pointers handle them quickly without extra overhead. Large Files: Indirect pointers allow the inode to scale up to support massive files by adding more layers of pointers. How It Works in Practice When the file system needs to find a specific block in a file:\nIt checks the inode’s direct pointers first. If the block number is beyond the direct pointers’ range, it follows the single indirect pointer to the indirect block and looks up the address there. For even larger block numbers, it traverses the double indirect or triple indirect pointers, following the hierarchy until it finds the right disk address. This process ensures the file system can efficiently locate any block, no matter how big the file is.\nReferences https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf https://grok.com/chat/d429de0e-556f-426c-84bd-21ff1b0c4002 (Contains reference to actual inode structure implementation along with locks it uses on Linux) https://grok.com/chat/c86e3040-2f86-4aa9-a317-1c0a464564a3?referrer=website ","permalink":"http://localhost:1313/blogs/file-system-implementation/","summary":"\u003ch2 id=\"overall-organization-of-data-in-disks\"\u003eOverall Organization Of Data In Disks\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eAssuming we have a 256KB disk\u003c/em\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDisk Blocks\u003c/strong\u003e: The basic units of storage on the disk, \u003cem\u003eeach 4 KB in size.\u003c/em\u003e The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInode Bitmap (i)\u003c/strong\u003e: Block 1; a bitmap tracking which inodes are free (0) or in-use (1).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eData Bitmap (d)\u003c/strong\u003e: Block 2; a bitmap tracking which data blocks are free (0) or allocated (1).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInode Table (I)\u003c/strong\u003e: Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks.\n5 blocks of 4KB will contain 80 256 byte inode strutures.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eData Region (D)\u003c/strong\u003e: Blocks 8-63; the largest section, storing the actual contents of files and directories.\n\u003cimg alt=\"Pasted image 20250301204506.png\" loading=\"lazy\" src=\"/blogs/media/pasted-image-20250301204506.png\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"inode\"\u003eInode\u003c/h2\u003e\n\u003cp\u003eEvery inode has a unique identifier called an \u003cstrong\u003einode number\u003c/strong\u003e (or \u003cstrong\u003ei-number\u003c/strong\u003e). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:\u003c/p\u003e","title":"Understanding Inodes and Disk Layout"},{"content":"Files and directories File systems virtualize persistent storage (e.g., hard drives, SSDs) into user-friendly files and directories, adding a third pillar to OS abstractions (processes for CPU, address spaces for memory).\nFile Paths and System Calls Files are organized in a tree-like directory structure, starting from the root (/). A file’s location is identified by its pathname (e.g., /home/user/file.txt). To interact with files, processes use system calls:\nopen(path, flags): Opens a file and returns a file descriptor (fd). read(fd, buffer, size): Reads data from the file into a buffer using the fd. write(fd, buffer, size): Writes data to the file via the fd. close(fd): Closes the file, freeing the fd. File Descriptors A file descriptor is a small integer, unique to each process, that identifies an open file. When a process calls open(), the operating system assigns it the next available fd (e.g., 3, 4, etc.). Every process starts with three default fds:\n0: Standard input (stdin) 1: Standard output (stdout) 2: Standard error (stderr) Quick Note: File Descriptors \u0026amp; Terminals Every process starts with three standard file descriptors:\n0 (stdin), 1 (stdout), 2 (stderr). Where They Point By default they link to a terminal device (e.g., /dev/pts/0 for Terminal 1, /dev/pts/1 for Terminal 2). These are character devices with a major number (e.g., 136) for the tty driver and a unique minor number (e.g., 0 or 1) for each instance.\nCommand Output (Terminal 1):\nls -l /proc/self/fd lrwx------ 1 runner runner 64 Feb 23 11:47 0 -\u0026gt; /dev/pts/0 lrwx------ 1 runner runner 64 Feb 23 11:47 1 -\u0026gt; /dev/pts/0 lrwx------ 1 runner runner 64 Feb 23 11:47 2 -\u0026gt; /dev/pts/0 Device Details:\nls -l /dev/pts/0 crw--w---- 1 runner tty 136, 0 Feb 23 11:53 /dev/pts/0 ~/workspace$ stat /dev/pts/0 File: /dev/pts/0 Size: 0 Blocks: 0 IO Block: 1024 character special file Device: 0,1350 Inode: 3 Links: 1 Device type: 136,0 Access: (0620/crw--w----) Uid: ( 1000/ runner) Gid: ( 5/ tty) Access: 2025-02-23 12:13:52.419852946 +0000 Modify: 2025-02-23 12:13:52.419852946 +0000 Change: 2025-02-23 11:36:28.419852946 +0000 Birth: - Versus a File A regular file descriptor (e.g., for test.txt) points to a disk inode with data blocks, tied to a filesystem device (e.g., /dev/sda1), not a driver.\nExample:\nls -li test.txt 12345 -rw-r--r-- 1 runner runner 5 Feb 23 12:00 test.txt ~/workspace$ stat test.txt File: test.txt Size: 288 Blocks: 8 IO Block: 4096 regular file Device: 0,375 Inode: 1111 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 1000/ runner) Gid: ( 1000/ runner) Access: 2025-02-23 11:40:57.014322027 +0000 Modify: 2025-02-23 11:41:41.800233516 +0000 Change: 2025-02-23 11:41:41.800233516 +0000 Birth: 2025-02-23 11:40:57.014322027 +0000 Fun Test Redirected Terminal 1’s output to Terminal 2:\nCommand: echo \u0026quot;Hello\u0026quot; \u0026gt; /dev/pts/1 Result: \u0026ldquo;Hello\u0026rdquo; appeared in Terminal 2 (/dev/pts/1, minor 1)! Open File Table The Open File Table (OFT) is a system-wide structure in kernel memory that tracks all open files. Each entry in the OFT includes:\nThe current offset (position for the next read/write). Permissions (e.g., read, write). A reference count (if multiple processes share the file). Each process has its own array of file descriptors, where each fd maps to an entry in the OFT. For example, process A’s fd 3 and process B’s fd 4 might point to the same OFT entry if they’ve opened the same file.\nExample: Showing entries of a PID in open file table\n~/workspace$ lsof -p 113 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME bash 113 runner cwd DIR 0,375 394 256 /home/runner/workspace bash 113 runner rtd DIR 0,1324 4096 1562007 / bash 113 runner 0u CHR 136,0 0t0 3 /dev/pts/0 bash 113 runner 1u CHR 136,0 0t0 3 /dev/pts/0 bash 113 runner 2u CHR 136,0 0t0 3 /dev/pts/0 bash 113 runner 255u CHR 136,0 0t0 3 /dev/pts/0 As you see above that the process had 0,1 and 2 FDs as well as FD for a directory as well.\nReference counting in OFT Reference counting is a technique used in operating systems to manage entries in the Open File Table (OFT), which stores information about open files shared by processes or file descriptors.\nHow It Works Each OFT entry has a reference count that tracks how many file descriptors (from one or more processes) refer to it. When a file is opened, the reference count increases by 1. If the same file is reused (e.g., via fork() or dup()), the count increments without creating a new entry. When a file descriptor is closed (e.g., with close(fd)), the count decreases by 1. The OFT entry is removed only when the reference count reaches 0, meaning no process is using it. How It Helps Remove Entries Reference counting ensures an OFT entry is deleted only when it’s no longer needed. For example, after a fork(), both parent and child processes share the same OFT entry (reference count = 2). Closing the file in one process lowers the count to 1, but the entry persists until the second process closes it, bringing the count to 0.\nWhy It’s Useful This method efficiently manages shared file resources, preventing premature removal of file metadata (like the current offset) while any process still needs it.\nINode What is an Inode? An inode (short for \u0026ldquo;index node\u0026rdquo;) is a fundamental data structure in UNIX-based file systems. It stores essential metadata about a file, enabling the system to manage and locate files efficiently. Each file in the system is uniquely identified by its inode number (also called i-number). The metadata stored in an inode includes:\nFile size: The total size of the file in bytes.\nPermissions: Access rights defining who can read, write, or execute the file.\nOwnership: User ID (UID) and group ID (GID) of the file\u0026rsquo;s owner.\nTimestamps:\nLast access time (when the file was last read). Last modification time (when the file\u0026rsquo;s content was last changed). Last status change time (when the file\u0026rsquo;s metadata, like permissions, was last modified). Pointers to data blocks: Locations on disk where the file\u0026rsquo;s actual content is stored.\nThe inode does not store the file\u0026rsquo;s name or its content; these are managed separately. The inode\u0026rsquo;s role is to provide a compact and efficient way to access a file\u0026rsquo;s metadata. Each inode is stored in inode block in disk.\nHow the stat System Call Works The stat system call is used to retrieve metadata about a file without accessing its actual content. It provides a way for programs to query information like file size, permissions, and timestamps. Here\u0026rsquo;s how it works:\nInput: The stat system call takes a file path as input. Locate the inode: The file system uses the file path to find the corresponding inode number. (Insert link to FS implemetation note here explaining how FS searches inode and data block from given file path) Retrieve metadata: The inode is fetched from disk (or from a cache, if available, for faster access). Populate the struct stat buffer: The metadata stored in the inode is copied into a struct stat buffer, which contains fields for file size, permissions, ownership, timestamps, and more. Return to the user: The struct stat buffer is returned to the calling program, providing all the metadata for the file. Because the stat system call only accesses the inode and not the file\u0026rsquo;s content, it is a fast and efficient operation. This separation of metadata (stored in the inode) and content (stored in data blocks) allows the system to quickly retrieve file information without unnecessary disk I/O.\nDirectories ls -al Output for Directories\ntotal 152 drwxr-xr-x 1 runner runner 394 Feb 23 11:40 . drwxrwxrwx 1 runner runner 46 Feb 23 11:36 .. -rw-r--r-- 1 runner runner 174 Feb 15 11:31 .breakpoints drwxr-xr-x 1 runner runner 34 Feb 15 11:32 .cache drwxr-x--- 1 runner runner 260 Feb 15 11:31 .ccls-cache -rw-r--r-- 1 runner runner 1564 Dec 21 11:44 common_threads.h -rwxr-xr-x 1 runner runner 16128 Dec 21 11:54 deadlock -rw-r--r-- 1 runner runner 647 Dec 21 11:51 deadlock.c -rwxr-xr-x 1 runner runner 16160 Dec 21 11:57 deadlock-global -rw-r--r-- 1 runner runner 748 Dec 21 11:57 deadlock-global.c -rw-r--r-- 1 runner runner 6320 Feb 23 11:36 generated-icon.png -rw-r--r-- 1 runner runner 429 Mar 8 2024 .gitignore -rwxr-xr-x 1 runner runner 15984 Dec 21 11:51 main -rw-r--r-- 1 runner runner 415 Dec 21 11:51 main.c -rwxr-xr-x 1 runner runner 16816 Aug 16 2024 main-debug -rw-r--r-- 1 runner runner 411 Dec 12 2023 Makefile -rwxr-xr-x 1 runner runner 16136 Dec 14 11:04 mem -rw-r--r-- 1 runner runner 1437 Aug 16 2024 .replit -rw-r--r-- 1 runner runner 134 Feb 23 13:54 replit.nix -rwxr-xr-x 1 runner runner 15936 Dec 21 11:59 signal -rw-r--r-- 1 runner runner 329 Dec 21 11:59 signal.c -rw-r--r-- 1 runner runner 288 Feb 23 11:41 test.txt drwxr-xr-x 1 runner runner 42 Feb 15 11:32 wcat Size of a directory only means storage needed to store each directory entry which basically comprise entry name and its inode number along with some other metdata\nDirectory Data Block Contents The data blocks of a directory contain:\nDirectory entries: Mapping of file/subdirectory names to their inode numbers. Special entries: . (current directory) and .. (parent directory). Optimization for Small Directories For small directories, some file systems store directory entries directly in the inode itself, avoiding separate data blocks. This optimization saves space and speeds up access.\nReading Directory Entries with System Calls To programmatically read directory contents following sys calls are used:\nopendir(path): Opens the directory. readdir(dir): Reads one entry at a time (returns a struct dirent with name and inode number. closedir(dir): Closes the directory. Permission bits and their octal representation Format: ls -l displays permissions as rwxr-xr-x:\nFirst character: d (directory), - (file), or l (symlink). Next 9 bits: Three groups of rwx for owner, group, and others: r = read, w = write, x = execute (run for files, enter for directories). Converting a Full 9-Bit Permission to Numeric (Octal) Representation Example: rwxr-xr-x\nBreakdown: Split into three groups (owner, group, others): Owner: rwx. Group: r-x. Others: r-x. Step-by-Step Conversion\nOwner: rwx: r = 1, w = 1, x = 1 → Binary: 111. Decimal: 1×4 + 1×2 + 1×1 = 4 + 2 + 1 = 7. Group: r-x: r = 1, w = 0, x = 1 → Binary: 101. Decimal: 1×4 + 0×2 + 1×1 = 4 + 1 = 5. Others: r-x: r = 1, w = 0, x = 1 → Binary: 101. Decimal: 1×4 + 0×2 + 1×1 = 4 + 1 = 5. Final Octal Representation\nCombine the three digits: 7 5 5. Result: rwxr-xr-x = 755. Quick Recall: Split rwx into 3 groups, convert each to binary (1s/0s), sum (4, 2, 1), get octal (e.g., 755). Hard Links, Symbolic Links (Including Size), and File Deletion (Based on OSTEP PDF) Hard Links and unlink Definition: A hard link (PDF p. 18-19) is an extra directory entry pointing to the same inode, created with link(old, new).. When a directory reference its parent directory (with ..) it increases hard link count by 1. For a new empty directory its hard count is always 2 since it is referred by itself (with .) and also referred by its parent\u0026rsquo;s directory entry (with ..) With unlink: Removes a name-to-inode link, decrements the inode’s link count. When count hits 0 (and no processes use it), the inode and data blocks are freed from disk. Symbolic Links and Dangling References Definition: A symbolic (soft) link (PDF p. 20-21) is a distinct file storing a pathname to another file, created with ln -s old new. Size: Its size equals the length of the stored pathname (e.g., 4 bytes for \u0026ldquo;file\u0026rdquo;, 15 bytes for \u0026ldquo;alongerfilename\u0026rdquo;; PDF p. 21). How It Works: References the path, not the inode directly; accessing it resolves the path. Dangling Reference: If the target is deleted (e.g., unlink file), the symbolic link persists but points to nothing, causing errors (e.g., \u0026ldquo;No such file or directory\u0026rdquo;). Disk, Partition, Volume, File System Hierarchy, and Mounting Distinction and Hierarchy Disk: Physical storage device (e.g., hard drive, SSD) holding raw data blocks. Partition: A subdivided section of a disk (e.g., /dev/sda1), treated as a separate unit. Volume: A logical abstraction, often a partition or group of partitions, formatted with a file system (FS). File System: Software structure (e.g., ext3, AFS) organizing data into files and directories on a volume. Hierarchy: Disk → Partitions → Volumes → File Systems.\nMounting Process Creation: Use mkfs to format a partition with a file system (e.g., mkfs -t ext3 /dev/sda1 creates an empty FS). Mounting: The mount command (PDF p. 24) attaches a file system to the directory tree at a mount point (e.g., mount -t ext3 /dev/sda1 /home/users), making its contents accessible under that path. Multiple File Systems on One Machine A single machine can host multiple file systems by mounting them at different points in the tree (PDF p. 26). Example Output (from mount): /dev/sda1 on / type ext3 (rw) # Root FS /dev/sda5 on /tmp type ext3 (rw) # Separate tmp FS AFS on /afs type afs (rw) # Distributed FS How: Each partition or volume gets its own FS type and mount point, unified under one tree (e.g., /). Quick Recall: Disk splits into partitions; volumes get FS; mount glues them into a tree; multiple FS coexist at different paths.\nReferences https://pages.cs.wisc.edu/~remzi/OSTEP/file-intro.pdf https://grok.com/share/bGVnYWN5_47ab49d6-aa1d-4de1-9bbe-0d47332e12fe https://grok.com/share/bGVnYWN5_7db77c97-d33d-4543-9993-d5aa362c8b2b ","permalink":"http://localhost:1313/blogs/files-and-directories/","summary":"\u003ch1 id=\"files-and-directories\"\u003eFiles and directories\u003c/h1\u003e\n\u003cp\u003eFile systems virtualize persistent storage (e.g., hard drives, SSDs) into user-friendly files and directories, adding a third pillar to OS abstractions (processes for CPU, address spaces for memory).\u003c/p\u003e\n\u003ch2 id=\"file-paths-and-system-calls\"\u003eFile Paths and System Calls\u003c/h2\u003e\n\u003cp\u003eFiles are organized in a \u003cstrong\u003etree-like directory structure\u003c/strong\u003e, starting from the root (/). A file’s location is identified by its \u003cstrong\u003epathname\u003c/strong\u003e (e.g., /home/user/file.txt). To interact with files, processes use \u003cstrong\u003esystem calls\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eopen(path, flags)\u003c/strong\u003e: Opens a file and returns a \u003cstrong\u003efile descriptor\u003c/strong\u003e (fd).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eread(fd, buffer, size)\u003c/strong\u003e: Reads data from the file into a buffer using the fd.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewrite(fd, buffer, size)\u003c/strong\u003e: Writes data to the file via the fd.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eclose(fd)\u003c/strong\u003e: Closes the file, freeing the fd.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"file-descriptors\"\u003eFile Descriptors\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003efile descriptor\u003c/strong\u003e is a small integer, unique to each process, that identifies an open file. When a process calls open(), the operating system assigns it the next available fd (e.g., 3, 4, etc.). Every process starts with three default fds:\u003c/p\u003e","title":"Files And Directories"}]