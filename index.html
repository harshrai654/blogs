<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.155.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Learning Loop</title><meta name=description content><meta name=author content><link rel=canonical href=https://harshrai654.github.io/blogs/><link crossorigin=anonymous href=/blogs/assets/css/stylesheet.4a2d4f6ce40ed4a68aae2b504ff6913b1f64bf1b352beea0c885d29c6d987670.css integrity="sha256-Si1PbOQO1KaKritQT/aROx9kvxs1K+6gyIXSnG2YdnA=" rel="preload stylesheet" as=style><link rel=icon href=https://harshrai654.github.io/blogs/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://harshrai654.github.io/blogs/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://harshrai654.github.io/blogs/favicon-32x32.png><link rel=apple-touch-icon href=https://harshrai654.github.io/blogs/apple-touch-icon.png><link rel=mask-icon href=https://harshrai654.github.io/blogs/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://harshrai654.github.io/blogs/index.xml><link rel=alternate type=application/json href=https://harshrai654.github.io/blogs/index.json><link rel=alternate hreflang=en href=https://harshrai654.github.io/blogs/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script data-goatcounter=https://ttharsh.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://harshrai654.github.io/blogs/ accesskey=h title="Learning Loop (Alt + H)">Learning Loop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi There üëã</h1></header><div class=entry-content>Hi, My name is Harsh, Welcome to my blog. Here I share whatever new things I learn or my past learnings while exploring system architecture, database internals, observability, and backend infrastructure‚Äîone deep dive at a time.</div><footer class=entry-footer><div class=social-icons><a href=https://github.com/harshrai654 target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://x.com/harshrai3 target=_blank rel="noopener noreferrer me" title=Twitter><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Debugging HTTP 503 UC Errors in Istio Service Mesh</h2></header><div class=entry-content><p>Background To obtain more relevant metrics and a comprehensive understanding of traces when external API requests access our systems, We opted to enable tracing for the network mesh components situated above the Kubernetes service. This specifically covers the entire request flow from its initiation: the ingress gateway receives the request and routes it according to defined rules to a particular K8s service; then, the Istio sidecar proxy containers, running alongside our application containers in the same pod, receive and proxy the request to main containers, where our Node.js server process ultimately handle it and generate the appropriate response. Before enabling tracing for istio mesh, tracing for a HTTP request began when the request reached our application container at the pod level, with HTTP auto-instrumentation serving as the trace root.
...</p></div><footer class=entry-footer><span title='2026-01-30 23:43:37 +0530 +0530'>January 30, 2026</span>&nbsp;¬∑&nbsp;10 min</footer><a class=entry-link aria-label="post link to Debugging HTTP 503 UC Errors in Istio Service Mesh" href=https://harshrai654.github.io/blogs/debugging-http-503-uc-errors-in-istio-service-mesh/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Networking Basics</h2></header><div class=entry-content><p>In this blog I will try to explain basics of networking concepts and how these concepts are used to create simple to complex networking topologies to transfer data between physical machines and with the use of network namespaces on Linux we will try to simulate various scenarios as we discuss the theory behind them.
Network Segments A network segment refers to a distinct part of a computer network that is isolated from the remainder of the network by a specific device, such as a repeater, hub, bridge, switch, or router. Within each segment, one or more computers or other hosts may reside. Depending on how these devices are connected, the network forms L1, L2 or L3 segments, Here the segment are mainly named on the basis of the layer of OSI networking model in which a segment mainly communicates.
...</p></div><footer class=entry-footer><span title='2026-01-12 22:20:37 +0530 +0530'>January 12, 2026</span>&nbsp;¬∑&nbsp;27 min</footer><a class=entry-link aria-label="post link to Networking Basics" href=https://harshrai654.github.io/blogs/networking-basics/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multipart Form Uploads - Busboy and Node Streams</h2></header><div class=entry-content><p>I was recently investigating ways to improve the efficiency of file uploads to a Node.js server. This need arose after encountering a production bug where the absence of a maximum file size limit for uploads led to an out-of-memory crash due to file buffers consuming excessive heap memory. In this Node.js server, I was using Express and express-openapi-validator to document the server‚Äôs API with an OpenAPI specification. express-openapi-validator utilizes multer for file uploads. I had previously encountered this library whenever file uploads from forms needed to be handled in Node.js, but I never questioned why a separate library was necessary for file uploads. This time, I decided to go deeper to understand if a dedicated package for file uploads is truly needed, and if so, what specific benefits Multer or similar libraries provide. I initially needed to find a configuration option in express-openapi-validator to set a request-wide limit on the maximum size (in bytes) of data allowed in a request, including all file attachments.¬†The express-openapi-validator package offers a fileUploader configuration (fileUploader documentation) that passes options directly to multer.
...</p></div><footer class=entry-footer><span title='2025-10-12 00:48:38 +0530 +0530'>October 12, 2025</span>&nbsp;¬∑&nbsp;17 min</footer><a class=entry-link aria-label="post link to Multipart Form Uploads - Busboy and Node Streams" href=https://harshrai654.github.io/blogs/multipart-form-uploads---busboy-and-node-streams/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Building Fault Tolerant KV Storage System - Part 2</h2></header><div class=entry-content><p>We previously discussed replicated state machines, leader election in the RAFT consensus algorithm, and log-based state maintenance. Now, we‚Äôll focus on log replication across peer servers. We‚Äôll also examine how RAFT ensures that the same commands are applied to the state machine at a given log index on every peer, because of the leader‚Äôs one-way log distribution to followers.
Leader Initialisation Once a candidate becomes leader we call setupLeader function which initiates go routine for each peer in the RAFT cluster, Each go routine of respective peer is responsible for replicating new log entries or sending heartbeat via AppendEntries RPC.
...</p></div><footer class=entry-footer><span title='2025-10-04 16:16:17 +0530 +0530'>October 4, 2025</span>&nbsp;¬∑&nbsp;32 min</footer><a class=entry-link aria-label="post link to Building Fault Tolerant KV Storage System - Part 2" href=https://harshrai654.github.io/blogs/building-fault-tolerant-kv-storage-system---part-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Building Fault Tolerant KV Storage System - Part 1</h2></header><div class=entry-content><p>This blog post is part of a series detailing my implementation of a fault-tolerant key-value server using the RAFT consensus protocol. Before diving into RAFT and its mechanics, it‚Äôs crucial to grasp the concept of a replicated state machine and its significance in building systems that are both fault-tolerant and highly available.
Replicated State Machine A replicated state machine is essentially a collection of identical machines working together. One machine acts as the ‚Äúmaster,‚Äù handling client requests and dictating the system‚Äôs operations. The other machines, the ‚Äúreplicas,‚Äù diligently copy the master‚Äôs state. This ‚Äústate‚Äù encompasses all the data necessary for the system to function correctly, remembering the effects of previous operations. Think of a key-value store: the state would be the key-value pairs themselves, replicated across all machines to maintain consistency and resilience. Having the master‚Äôs state copied across multiple machines enables us to use these replicas in several ways. They can take over as the new master if the original fails, or handle read operations to reduce the load on the master. Because the state is copied across machines, network issues like latency, packet loss, and packet reordering significantly affect how closely a replica‚Äôs state matches the master‚Äôs. The difference between the master‚Äôs (most up-to-date) state and a replica‚Äôs state is known as replication lag. Generally, we aim to minimize this lag, and different systems offer varying levels of consistency (which we will discuss later when covering replication in RAFT).
...</p></div><footer class=entry-footer><span title='2025-10-03 20:38:34 +0530 +0530'>October 3, 2025</span>&nbsp;¬∑&nbsp;23 min</footer><a class=entry-link aria-label="post link to Building Fault Tolerant KV Storage System - Part 1" href=https://harshrai654.github.io/blogs/building-fault-tolerant-kv-storage-system---part-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Map Reduce</h2></header><div class=entry-content><p>This article shares learnings from Google‚Äôs influential MapReduce paper and explores the challenges encountered while implementing a simplified version. Our system uses multiple worker processes, running on a single¬†machine and communicating via RPC, to mimic key aspects of a distributed environment.
What is Map-Reduce At its core, MapReduce is a programming model and an associated¬†framework for processing and generating massive datasets using a parallel, distributed algorithm, typically on a cluster of computers. You might already be familiar¬†with¬†map¬†and¬†reduce¬†operations from functional programming languages. For instance, in JavaScript,¬†array.map()¬†transforms¬†each element of an array independently based on a¬†mapper¬†function, while¬†array.reduce()¬†iterates through an array, applying a¬†reducer¬†function to accumulate its elements into a single output value (e.g., a sum, or¬†a new, aggregated object).
...</p></div><footer class=entry-footer><span title='2025-05-31 12:49:54 +0530 +0530'>May 31, 2025</span>&nbsp;¬∑&nbsp;34 min</footer><a class=entry-link aria-label="post link to Map Reduce" href=https://harshrai654.github.io/blogs/map-reduce/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Debugging Redis Latency</h2></header><div class=entry-content><p>This article is about how at work we solved the issue of high response time while executing Redis commands from Node.js server to a Redis compatible database known as dragonfly.
Background After introducing metrics to our Node.js service, we started recording the overall response time whenever a Redis command was executed. We had a wrapper service around a Redis driver known as ioredis for interacting with our Redis-compatible database. Once we set up Grafana dashboards for metrics like cache latency, we saw unusually high p99 latency numbers, close to 200ms. This is a very large number, especially considering the underlying database query itself typically takes less than 10ms to complete. To understand why this latency was so high, we needed more detailed insight than metrics alone could provide. As part of a broader effort to set up our observability stack, I had been exploring various tracing solutions ‚Äì options ranged from open-source SDKs (OpenTelemetry Node.js SDK) with a self-deployed trace backend, to third-party managed solutions (Datadog, Middleware, etc.). For this investigation, we decided to proceed with a self-hosted Grafana Tempo instance to test the setup and feasibility. (So far, the setup is working great, and I‚Äôm planning a detailed blog post on our observability architecture soon). With tracing set up, we could get a waterfall view of the path taken by the service while responding to things like HTTP requests or event processing, which we hoped would pinpoint the source of the delay in our Redis command execution.
...</p></div><footer class=entry-footer><span title='2025-04-06 14:21:54 +0530 +0530'>April 6, 2025</span>&nbsp;¬∑&nbsp;11 min</footer><a class=entry-link aria-label="post link to Debugging Redis Latency" href=https://harshrai654.github.io/blogs/debugging-redis-latency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Socket File Descriptor and TCP connections</h2></header><div class=entry-content><p>Socket File Descriptors and Their Kernel Structures A socket is a special type of file descriptor (FD) in Linux, represented as socket:[inode]. Unlike regular file FDs, socket FDs point to in-memory kernel structures, not disk inodes. The /proc/&lt;pid>/fd directory lists all FDs for a process, including sockets. The inode number of a socket can be used to inspect its details via tools like ss and /proc/net/tcp. Example: Checking Open FDs for Process 216 ls -l /proc/216/fd Output:
...</p></div><footer class=entry-footer><span title='2025-03-02 16:15:01 +0530 +0530'>March 2, 2025</span>&nbsp;¬∑&nbsp;4 min</footer><a class=entry-link aria-label="post link to Socket File Descriptor and TCP connections" href=https://harshrai654.github.io/blogs/socket-file-descriptor-and-tcp-connections/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Understanding Inodes and Disk Layout</h2></header><div class=entry-content><p>Overall Organization Of Data In Disks Assuming we have a 256KB disk.
Disk Blocks: The basic units of storage on the disk, each 4 KB in size. The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks). Inode Bitmap (i): Block 1; a bitmap tracking which inodes are free (0) or in-use (1). Data Bitmap (d): Block 2; a bitmap tracking which data blocks are free (0) or allocated (1). Inode Table (I): Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks. 5 blocks of 4KB will contain 80 256 byte inode strutures. Data Region (D): Blocks 8-63; the largest section, storing the actual contents of files and directories. Inode Every inode has a unique identifier called an inode number (or i-number). This number acts like a file‚Äôs address in the file system, allowing the operating system to quickly locate its inode. For example:
...</p></div><footer class=entry-footer><span title='2025-03-01 20:41:00 +0000 UTC'>March 1, 2025</span>&nbsp;¬∑&nbsp;6 min</footer><a class=entry-link aria-label="post link to Understanding Inodes and Disk Layout" href=https://harshrai654.github.io/blogs/file-system-implementation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Files And Directories</h2></header><div class=entry-content><p>Files and directories File systems virtualize persistent storage (e.g., hard drives, SSDs) into user-friendly files and directories, adding a third pillar to OS abstractions (processes for CPU, address spaces for memory).
File Paths and System Calls Files are organized in a tree-like directory structure, starting from the root (/). A file‚Äôs location is identified by its pathname (e.g., /home/user/file.txt). To interact with files, processes use system calls:
open(path, flags): Opens a file and returns a file descriptor (fd). read(fd, buffer, size): Reads data from the file into a buffer using the fd. write(fd, buffer, size): Writes data to the file via the fd. close(fd): Closes the file, freeing the fd. File Descriptors A file descriptor is a small integer, unique to each process, that identifies an open file. When a process calls open(), the operating system assigns it the next available fd (e.g., 3, 4, etc.). Every process starts with three default fds:
...</p></div><footer class=entry-footer><span title='2025-02-23 20:41:00 +0000 UTC'>February 23, 2025</span>&nbsp;¬∑&nbsp;11 min</footer><a class=entry-link aria-label="post link to Files And Directories" href=https://harshrai654.github.io/blogs/files-and-directories/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://harshrai654.github.io/blogs/page/2/>Next&nbsp;&nbsp;¬ª</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://harshrai654.github.io/blogs/>Learning Loop</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";

  
  function isDarkMode() {
    return (
      document.body.classList.contains("dark") ||
      localStorage.getItem("pref-theme") === "dark" ||
      (!localStorage.getItem("pref-theme") &&
        window.matchMedia("(prefers-color-scheme: dark)").matches)
    );
  }

  
  mermaid.initialize({
    startOnLoad: true,
    theme: isDarkMode() ? "dark" : "default",
    themeVariables: {
      dark: {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#ffffff",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#ffffff",
        secondaryColor: "#4ecdc4",
        tertiaryColor: "#45b7d1",
        background: "#1a1a1a",
        mainBkg: "#2d2d2d",
        secondBkg: "#3d3d3d",
        tertiaryBkg: "#4d4d4d",
      },
      default: {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#000000",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#000000",
        secondaryColor: "#4ecdc4",
        tertiaryColor: "#45b7d1",
      },
    },
  });

  
  const themeToggle = document.getElementById("theme-toggle");
  if (themeToggle) {
    themeToggle.addEventListener("click", () => {
      setTimeout(() => {
        mermaid.initialize({
          startOnLoad: false,
          theme: isDarkMode() ? "dark" : "default",
          themeVariables: {
            dark: {
              primaryColor: "#ff6b6b",
              primaryTextColor: "#ffffff",
              primaryBorderColor: "#ff6b6b",
              lineColor: "#ffffff",
              secondaryColor: "#4ecdc4",
              tertiaryColor: "#45b7d1",
              background: "#1a1a1a",
              mainBkg: "#2d2d2d",
              secondBkg: "#3d3d3d",
              tertiaryBkg: "#4d4d4d",
            },
            default: {
              primaryColor: "#ff6b6b",
              primaryTextColor: "#000000",
              primaryBorderColor: "#ff6b6b",
              lineColor: "#000000",
              secondaryColor: "#4ecdc4",
              tertiaryColor: "#45b7d1",
            },
          },
        });

        
        document.querySelectorAll(".mermaid").forEach((element) => {
          element.removeAttribute("data-processed");
          mermaid.init(undefined, element);
        });
      }, 100);
    });
  }
</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>