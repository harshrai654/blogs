<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding Inodes and Disk Layout | Learning Loop</title>
<meta name=keywords content="FileSystem,Disk,Indexes"><meta name=description content="Overall Organization Of Data In Disks
Assuming we have a 256KB disk.

Disk Blocks: The basic units of storage on the disk, each 4 KB in size. The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks).
Inode Bitmap (i): Block 1; a bitmap tracking which inodes are free (0) or in-use (1).
Data Bitmap (d): Block 2; a bitmap tracking which data blocks are free (0) or allocated (1).
Inode Table (I): Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks.
5 blocks of 4KB will contain 80 256 byte inode strutures.
Data Region (D): Blocks 8-63; the largest section, storing the actual contents of files and directories.


Inode
Every inode has a unique identifier called an inode number (or i-number). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:"><meta name=author content><link rel=canonical href=https://harshrai654.github.io/blogs/file-system-implementation/><link crossorigin=anonymous href=/blogs/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://harshrai654.github.io/blogs/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://harshrai654.github.io/blogs/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://harshrai654.github.io/blogs/favicon-32x32.png><link rel=apple-touch-icon href=https://harshrai654.github.io/blogs/apple-touch-icon.png><link rel=mask-icon href=https://harshrai654.github.io/blogs/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://harshrai654.github.io/blogs/file-system-implementation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://harshrai654.github.io/blogs/file-system-implementation/"><meta property="og:site_name" content="Learning Loop"><meta property="og:title" content="Understanding Inodes and Disk Layout"><meta property="og:description" content="Overall Organization Of Data In Disks Assuming we have a 256KB disk.
Disk Blocks: The basic units of storage on the disk, each 4 KB in size. The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks). Inode Bitmap (i): Block 1; a bitmap tracking which inodes are free (0) or in-use (1). Data Bitmap (d): Block 2; a bitmap tracking which data blocks are free (0) or allocated (1). Inode Table (I): Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks. 5 blocks of 4KB will contain 80 256 byte inode strutures. Data Region (D): Blocks 8-63; the largest section, storing the actual contents of files and directories. Inode Every inode has a unique identifier called an inode number (or i-number). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:published_time" content="2025-03-01T20:41:00+00:00"><meta property="article:modified_time" content="2025-03-01T20:41:00+00:00"><meta property="article:tag" content="FileSystem"><meta property="article:tag" content="Disk"><meta property="article:tag" content="Indexes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding Inodes and Disk Layout"><meta name=twitter:description content="Overall Organization Of Data In Disks
Assuming we have a 256KB disk.

Disk Blocks: The basic units of storage on the disk, each 4 KB in size. The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks).
Inode Bitmap (i): Block 1; a bitmap tracking which inodes are free (0) or in-use (1).
Data Bitmap (d): Block 2; a bitmap tracking which data blocks are free (0) or allocated (1).
Inode Table (I): Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks.
5 blocks of 4KB will contain 80 256 byte inode strutures.
Data Region (D): Blocks 8-63; the largest section, storing the actual contents of files and directories.


Inode
Every inode has a unique identifier called an inode number (or i-number). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Understanding Inodes and Disk Layout","item":"https://harshrai654.github.io/blogs/file-system-implementation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding Inodes and Disk Layout","name":"Understanding Inodes and Disk Layout","description":"Overall Organization Of Data In Disks Assuming we have a 256KB disk.\nDisk Blocks: The basic units of storage on the disk, each 4 KB in size. The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks). Inode Bitmap (i): Block 1; a bitmap tracking which inodes are free (0) or in-use (1). Data Bitmap (d): Block 2; a bitmap tracking which data blocks are free (0) or allocated (1). Inode Table (I): Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks. 5 blocks of 4KB will contain 80 256 byte inode strutures. Data Region (D): Blocks 8-63; the largest section, storing the actual contents of files and directories. Inode Every inode has a unique identifier called an inode number (or i-number). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:\n","keywords":["FileSystem","Disk","Indexes"],"articleBody":"Overall Organization Of Data In Disks Assuming we have a 256KB disk.\nDisk Blocks: The basic units of storage on the disk, each 4 KB in size. The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks). Inode Bitmap (i): Block 1; a bitmap tracking which inodes are free (0) or in-use (1). Data Bitmap (d): Block 2; a bitmap tracking which data blocks are free (0) or allocated (1). Inode Table (I): Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks. 5 blocks of 4KB will contain 80 256 byte inode strutures. Data Region (D): Blocks 8-63; the largest section, storing the actual contents of files and directories. Inode Every inode has a unique identifier called an inode number (or i-number). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:\nIn a system with 80 inodes, numbers might range from 0 to 79. Conventionally, the root directory is assigned inode number 2 (numbers 0 and 1 are often reserved or used for special purposes). The inode number is the key to finding a file’s metadata on the disk, and it’s stored in directory entries alongside the file’s name.\nHow Do We Jump to the Disk Block for a Specific Inode Number? In a file system like vsfs, inodes are stored consecutively in an inode table, a reserved area of the disk (e.g., spanning blocks 3 to 7). Each inode has a fixed size—let’s say 256 bytes—and the disk is divided into blocks (e.g., 4096 bytes each). To locate a specific inode given its i-number, we calculate its exact position on the disk. Here’s how:\nIdentify the Inode Table’s Starting Block: Suppose the inode table starts at block 3. Calculate the Block Containing the Inode: Formula: block = (i-number * inode_size) / block_size + start_block Example: For inode 10, inode_size = 256 bytes, block_size = 4096 bytes, start_block = 3 (10 * 256) / 4096 = 2560 / 4096 = 0.625 → integer part is 0. block = 0 + 3 = 3. So, inode 10 is in block 3. Calculate the Offset Within the Block: Formula: offset = (i-number * inode_size) % block_size Example: (10 * 256) % 4096 = 2560 % 4096 = 2560 bytes. Inode 10 starts 2560 bytes into block 3. Result: The operating system reads block 3 from the disk and jumps to offset 2560 bytes to access inode 10’s metadata. This process allows the file system to efficiently retrieve an inode’s information and, from there, its data blocks. Since multiple processes may have file descriptors for the same file opened with their own data of offset to read from, multiple processes will be accessing the same inode structure to read about file and modify its data (Here inodes data would mean modifying things like last accessed time or adding another entry for list of data blocks etc), So i-node needs some sort of concurrency control in place. (More on this)\nHow does inode know the data it owns An inode is a data structure in a file system that stores information about a file, including where its data is located on the disk. Instead of holding the file’s data itself, the inode contains pointers that reference the disk blocks where the data is stored.\nDisk Blocks: These are fixed-size chunks of storage on the disk (e.g., 4 KB each) that hold the actual file content. Pointers: These are entries in the inode that specify the locations of these disk blocks. The inode uses these pointers to keep track of all the blocks that make up a file, allowing the file system to retrieve the data when needed.\nWhat Are Disk Addresses? Disk addresses are the identifiers that tell the file system the exact physical locations of data blocks on the disk. Think of them as a map: each address corresponds to a specific block, such as block number 100, which might map to a particular sector and track on a hard drive.\nFor example, if a file is 8 KB and the block size is 4 KB, the inode might have two pointers with disk addresses like “block 50” and “block 51,” pointing to the two blocks that hold the file’s data. How Does an Inode Manage Disk Blocks? The inode organizes its pointers in a way that can handle files of different sizes efficiently. It uses a combination of direct pointers and indirect pointers, forming a multi-level indexing structure.\n1. Direct Pointers The inode starts with a set of direct pointers, which point straight to the disk addresses of data blocks. Example: If the block size is 4 KB and the inode has 12 direct pointers, it can directly address 12 × 4 KB = 48 KB of data. 2. Indirect Pointers (Multi-Level Indexing) For files too big for direct pointers alone, the inode uses indirect pointers, which point to special blocks that themselves contain more pointers. This creates a hierarchical, or multi-level, structure.\nSingle Indirect Pointer\nThis pointer points to a block (called an indirect block) that contains a list of disk addresses to data blocks.\nExample: If a block is 4 KB and each pointer is 4 bytes, the indirect block can hold 4 KB / 4 bytes = 1024 pointers. That’s 1024 × 4 KB = 4 MB of additional data.\nTotal with Direct: With 12 direct pointers and 1 single indirect pointer, the file can reach (12 + 1024) × 4 KB = 4,096 KB (about 4 MB).\nDouble Indirect Pointer\nThis pointer points to a block that contains pointers to other single indirect blocks, each of which points to data blocks.\nExample: The double indirect block might hold 1024 pointers to single indirect blocks. Each of those holds 1024 pointers to data blocks, so that’s 1024 × 1024 = 1,048,576 data blocks, or about 4 GB with 4 KB blocks.\nTotal with Direct and Single: (12 + 1024 + 1,048,576) × 4 KB ≈ 4 GB.\nThis structure acts like an imbalanced tree: small files use only direct pointers, while larger files use additional levels of indirection as needed.\nWhy Use Multi-Level Indexing? The multi-level indexing structure is designed to balance efficiency and scalability:\nSmall Files: Most files are small, so direct pointers handle them quickly without extra overhead. Large Files: Indirect pointers allow the inode to scale up to support massive files by adding more layers of pointers. How It Works in Practice When the file system needs to find a specific block in a file:\nIt checks the inode’s direct pointers first. If the block number is beyond the direct pointers’ range, it follows the single indirect pointer to the indirect block and looks up the address there. For even larger block numbers, it traverses the double indirect or triple indirect pointers, following the hierarchy until it finds the right disk address. This process ensures the file system can efficiently locate any block, no matter how big the file is.\nReferences https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf https://grok.com/chat/d429de0e-556f-426c-84bd-21ff1b0c4002 (Contains reference to actual inode structure implementation along with locks it uses on Linux) https://grok.com/chat/c86e3040-2f86-4aa9-a317-1c0a464564a3?referrer=website ","wordCount":"1210","inLanguage":"en","datePublished":"2025-03-01T20:41:00Z","dateModified":"2025-03-01T20:41:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://harshrai654.github.io/blogs/file-system-implementation/"},"publisher":{"@type":"Organization","name":"Learning Loop","logo":{"@type":"ImageObject","url":"https://harshrai654.github.io/blogs/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://harshrai654.github.io/blogs/ accesskey=h title="Learning Loop (Alt + H)">Learning Loop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://harshrai654.github.io/blogs/>Home</a></div><h1 class="post-title entry-hint-parent">Understanding Inodes and Disk Layout</h1><div class=post-meta><span title='2025-03-01 20:41:00 +0000 UTC'>March 1, 2025</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#overall-organization-of-data-in-disks aria-label="Overall Organization Of Data In Disks">Overall Organization Of Data In Disks</a></li><li><a href=#inode aria-label=Inode>Inode</a><ul><li><a href=#how-do-we-jump-to-the-disk-block-for-a-specific-inode-number aria-label="How Do We Jump to the Disk Block for a Specific Inode Number?">How Do We Jump to the Disk Block for a Specific Inode Number?</a></li><li><a href=#how-does-inode-know-the-data-it-owns aria-label="How does inode know the data it owns">How does inode know the data it owns</a></li><li><a href=#what-are-disk-addresses aria-label="What Are Disk Addresses?">What Are Disk Addresses?</a></li><li><a href=#how-does-an-inode-manage-disk-blocks aria-label="How Does an Inode Manage Disk Blocks?">How Does an Inode Manage Disk Blocks?</a><ul><li><a href=#1-direct-pointers aria-label="1. Direct Pointers">1. Direct Pointers</a></li><li><a href=#2-indirect-pointers-multi-level-indexing aria-label="2. Indirect Pointers (Multi-Level Indexing)">2. Indirect Pointers (Multi-Level Indexing)</a></li></ul></li><li><a href=#why-use-multi-level-indexing aria-label="Why Use Multi-Level Indexing?">Why Use Multi-Level Indexing?</a></li><li><a href=#how-it-works-in-practice aria-label="How It Works in Practice">How It Works in Practice</a></li></ul></li></ul><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><h2 id=overall-organization-of-data-in-disks>Overall Organization Of Data In Disks<a hidden class=anchor aria-hidden=true href=#overall-organization-of-data-in-disks>#</a></h2><p><em>Assuming we have a 256KB disk</em>.</p><ul><li><strong>Disk Blocks</strong>: The basic units of storage on the disk, <em>each 4 KB in size.</em> The disk is divided into these blocks, numbered from 0 to N-1 (where N is the total number of blocks).</li><li><strong>Inode Bitmap (i)</strong>: Block 1; a bitmap tracking which inodes are free (0) or in-use (1).</li><li><strong>Data Bitmap (d)</strong>: Block 2; a bitmap tracking which data blocks are free (0) or allocated (1).</li><li><strong>Inode Table (I)</strong>: Blocks 3-7; an array of inodes, where each inode (256 bytes) holds metadata about a file, like size, permissions, and pointers to data blocks.
5 blocks of 4KB will contain 80 256 byte inode strutures.</li><li><strong>Data Region (D)</strong>: Blocks 8-63; the largest section, storing the actual contents of files and directories.
<img alt="Pasted image 20250301204506.png" loading=lazy src=/blogs/media/pasted-image-20250301204506.png></li></ul><h2 id=inode>Inode<a hidden class=anchor aria-hidden=true href=#inode>#</a></h2><p>Every inode has a unique identifier called an <strong>inode number</strong> (or <strong>i-number</strong>). This number acts like a file’s address in the file system, allowing the operating system to quickly locate its inode. For example:</p><ul><li>In a system with 80 inodes, numbers might range from 0 to 79.</li><li>Conventionally, the <strong>root directory</strong> is assigned inode number 2 (numbers 0 and 1 are often reserved or used for special purposes).</li></ul><p>The inode number is the key to finding a file’s metadata on the disk, and it’s stored in directory entries alongside the file’s name.</p><h3 id=how-do-we-jump-to-the-disk-block-for-a-specific-inode-number>How Do We Jump to the Disk Block for a Specific Inode Number?<a hidden class=anchor aria-hidden=true href=#how-do-we-jump-to-the-disk-block-for-a-specific-inode-number>#</a></h3><p><img alt="Pasted image 20250301210115.png" loading=lazy src=/blogs/media/pasted-image-20250301210115.png></p><p>In a file system like vsfs, inodes are stored consecutively in an <strong>inode table</strong>, a reserved area of the disk (e.g., spanning blocks 3 to 7). Each inode has a fixed size—let’s say 256 bytes—and the disk is divided into blocks (e.g., 4096 bytes each). To locate a specific inode given its i-number, we calculate its exact position on the disk. Here’s how:</p><ol><li><strong>Identify the Inode Table’s Starting Block</strong>:<ul><li>Suppose the inode table starts at block 3.</li></ul></li><li><strong>Calculate the Block Containing the Inode</strong>:<ul><li>Formula: block = <code>(i-number * inode_size) / block_size + start_block</code></li><li>Example: For <strong>inode 10, inode_size = 256 bytes, block_size = 4096 bytes</strong>,
start_block = 3<ul><li><code>(10 * 256) / 4096 = 2560 / 4096 = 0.625 → integer part is 0.</code></li><li><code>block = 0 + 3 = 3.</code></li><li><code>So, inode 10 is in block 3.</code></li></ul></li></ul></li><li><strong>Calculate the Offset Within the Block</strong>:<ul><li>Formula: offset = <code>(i-number * inode_size) % block_size</code></li><li>Example: <code>(10 * 256) % 4096 = 2560 % 4096 = 2560 bytes.</code></li><li>Inode 10 starts 2560 bytes into block 3.</li></ul></li><li><strong>Result</strong>:<ul><li>The operating system <em>reads block 3 from the disk and jumps to offset 2560 bytes to access inode 10’s metadata</em>.</li><li></li></ul></li></ol><p>This process allows the file system to efficiently retrieve an inode’s information and, from there, its data blocks.
Since multiple processes may have file descriptors for the same file opened with their own data of offset to read from, multiple processes will be accessing the same inode structure to read about file and modify its data (Here inodes data would mean modifying things like last accessed time or adding another entry for list of data blocks etc), So i-node needs some sort of concurrency control in place. <a href=https://grok.com/chat/d429de0e-556f-426c-84bd-21ff1b0c4002>(More on this</a>)</p><h3 id=how-does-inode-know-the-data-it-owns>How does inode know the data it owns<a hidden class=anchor aria-hidden=true href=#how-does-inode-know-the-data-it-owns>#</a></h3><p>An <strong>inode</strong> is a data structure in a file system that stores information about a file, including where its data is located on the disk. Instead of holding the file’s data itself, the inode contains <strong>pointers</strong> that reference the <strong>disk blocks</strong> where the data is stored.</p><ul><li><strong>Disk Blocks</strong>: These are fixed-size chunks of storage on the disk (e.g., 4 KB each) that hold the actual file content.</li><li><strong>Pointers</strong>: These are entries in the inode that specify the locations of these disk blocks.</li></ul><p>The inode uses these pointers to keep track of all the blocks that make up a file, allowing the file system to retrieve the data when needed.</p><h3 id=what-are-disk-addresses>What Are Disk Addresses?<a hidden class=anchor aria-hidden=true href=#what-are-disk-addresses>#</a></h3><p><strong>Disk addresses</strong> are the identifiers that tell the file system the exact physical locations of data blocks on the disk. Think of them as a map: each address corresponds to a specific block, such as block number 100, which might map to a particular sector and track on a hard drive.</p><ul><li>For example, if a file is 8 KB and the block size is 4 KB, the inode might have two pointers with disk addresses like &ldquo;block 50&rdquo; and &ldquo;block 51,&rdquo; pointing to the two blocks that hold the file’s data.</li></ul><h3 id=how-does-an-inode-manage-disk-blocks>How Does an Inode Manage Disk Blocks?<a hidden class=anchor aria-hidden=true href=#how-does-an-inode-manage-disk-blocks>#</a></h3><p>The inode organizes its pointers in a way that can handle files of different sizes efficiently. It uses a combination of <strong>direct pointers</strong> and <strong>indirect pointers</strong>, forming a <strong>multi-level indexing structure</strong>.</p><h4 id=1-direct-pointers>1. <strong>Direct Pointers</strong><a hidden class=anchor aria-hidden=true href=#1-direct-pointers>#</a></h4><ul><li>The inode starts with a set of <strong>direct pointers</strong>, which point straight to the disk addresses of data blocks.</li><li><strong>Example</strong>: If the block size is 4 KB and the inode has 12 direct pointers, it can directly address 12 × 4 KB = 48 KB of data.</li></ul><h4 id=2-indirect-pointers-multi-level-indexing>2. <strong>Indirect Pointers (Multi-Level Indexing)</strong><a hidden class=anchor aria-hidden=true href=#2-indirect-pointers-multi-level-indexing>#</a></h4><p>For files too big for direct pointers alone, the inode uses <strong>indirect pointers</strong>, which point to special blocks that themselves contain more pointers. This creates a hierarchical, or <strong>multi-level</strong>, structure.</p><ul><li><p><strong>Single Indirect Pointer</strong></p><ul><li><p>This pointer points to a block (called an indirect block) that contains a list of disk addresses to data blocks.</p></li><li><p><strong>Example</strong>: If a block is 4 KB and each pointer is 4 bytes, the indirect block can hold 4 KB / 4 bytes = 1024 pointers. That’s 1024 × 4 KB = 4 MB of additional data.</p></li><li><p><strong>Total with Direct</strong>: With 12 direct pointers and 1 single indirect pointer, the file can reach (12 + 1024) × 4 KB = 4,096 KB (about 4 MB).</p></li></ul></li><li><p><strong>Double Indirect Pointer</strong></p><ul><li><p>This pointer points to a block that contains pointers to other single indirect blocks, each of which points to data blocks.</p></li><li><p><strong>Example</strong>: The double indirect block might hold 1024 pointers to single indirect blocks. Each of those holds 1024 pointers to data blocks, so that’s 1024 × 1024 = 1,048,576 data blocks, or about 4 GB with 4 KB blocks.</p></li><li><p><strong>Total with Direct and Single</strong>: (12 + 1024 + 1,048,576) × 4 KB ≈ 4 GB.</p></li></ul></li></ul><p>This structure acts like an <strong>imbalanced tree</strong>: small files use only direct pointers, while larger files use additional levels of indirection as needed.</p><hr><h3 id=why-use-multi-level-indexing>Why Use Multi-Level Indexing?<a hidden class=anchor aria-hidden=true href=#why-use-multi-level-indexing>#</a></h3><p>The multi-level indexing structure is designed to balance <strong>efficiency</strong> and <strong>scalability</strong>:</p><ul><li><strong>Small Files</strong>: Most files are small, so direct pointers handle them quickly without extra overhead.</li><li><strong>Large Files</strong>: Indirect pointers allow the inode to scale up to support massive files by adding more layers of pointers.</li></ul><hr><h3 id=how-it-works-in-practice>How It Works in Practice<a hidden class=anchor aria-hidden=true href=#how-it-works-in-practice>#</a></h3><p>When the file system needs to find a specific block in a file:</p><ol><li>It checks the inode’s <strong>direct pointers</strong> first.</li><li>If the block number is beyond the direct pointers’ range, it follows the <strong>single indirect pointer</strong> to the indirect block and looks up the address there.</li><li>For even larger block numbers, it traverses the <strong>double indirect</strong> or <strong>triple indirect</strong> pointers, following the hierarchy until it finds the right disk address.</li></ol><p>This process ensures the file system can efficiently locate any block, no matter how big the file is.</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ul><li><a href=https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf>https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf</a></li><li><a href=https://grok.com/chat/d429de0e-556f-426c-84bd-21ff1b0c4002>https://grok.com/chat/d429de0e-556f-426c-84bd-21ff1b0c4002</a> (Contains reference to actual inode structure implementation along with locks it uses on Linux)</li><li><a href="https://grok.com/chat/c86e3040-2f86-4aa9-a317-1c0a464564a3?referrer=website">https://grok.com/chat/c86e3040-2f86-4aa9-a317-1c0a464564a3?referrer=website</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://harshrai654.github.io/blogs/tags/filesystem/>FileSystem</a></li><li><a href=https://harshrai654.github.io/blogs/tags/disk/>Disk</a></li><li><a href=https://harshrai654.github.io/blogs/tags/indexes/>Indexes</a></li></ul><nav class=paginav><a class=prev href=https://harshrai654.github.io/blogs/socket-file-descriptor-and-tcp-connections/><span class=title>« Prev</span><br><span>Socket File Descriptor and TCP connections</span>
</a><a class=next href=https://harshrai654.github.io/blogs/files-and-directories/><span class=title>Next »</span><br><span>Files And Directories</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Inodes and Disk Layout on x" href="https://x.com/intent/tweet/?text=Understanding%20Inodes%20and%20Disk%20Layout&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2ffile-system-implementation%2f&amp;hashtags=FileSystem%2cDisk%2cIndexes"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Inodes and Disk Layout on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2ffile-system-implementation%2f&amp;title=Understanding%20Inodes%20and%20Disk%20Layout&amp;summary=Understanding%20Inodes%20and%20Disk%20Layout&amp;source=https%3a%2f%2fharshrai654.github.io%2fblogs%2ffile-system-implementation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Inodes and Disk Layout on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fharshrai654.github.io%2fblogs%2ffile-system-implementation%2f&title=Understanding%20Inodes%20and%20Disk%20Layout"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Inodes and Disk Layout on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fharshrai654.github.io%2fblogs%2ffile-system-implementation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Inodes and Disk Layout on whatsapp" href="https://api.whatsapp.com/send?text=Understanding%20Inodes%20and%20Disk%20Layout%20-%20https%3a%2f%2fharshrai654.github.io%2fblogs%2ffile-system-implementation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Inodes and Disk Layout on telegram" href="https://telegram.me/share/url?text=Understanding%20Inodes%20and%20Disk%20Layout&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2ffile-system-implementation%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Understanding Inodes and Disk Layout on ycombinator" href="https://news.ycombinator.com/submitlink?t=Understanding%20Inodes%20and%20Disk%20Layout&u=https%3a%2f%2fharshrai654.github.io%2fblogs%2ffile-system-implementation%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://harshrai654.github.io/blogs/>Learning Loop</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>