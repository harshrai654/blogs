<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Debugging HTTP 503 UC Errors in Istio Service Mesh | Learning Loop</title><meta name=keywords content="Networking,NodeJS,TCP,Containers,Kubernetes,Observability"><meta name=description content="Background
To obtain more relevant metrics and a comprehensive understanding of traces when external API requests access our systems, We opted to enable tracing for the network mesh components situated above the Kubernetes service. This specifically covers the entire request flow from its initiation: the ingress gateway receives the request and routes it according to defined rules to a particular K8s service; then, the Istio sidecar proxy containers, running alongside our application containers in the same pod, receive and proxy the request to main containers, where our Node.js server process ultimately handle it and generate the appropriate response.
Before enabling tracing for istio mesh, tracing for a HTTP request began when the request reached our application container at the pod level, with HTTP auto-instrumentation serving as the trace root."><meta name=author content><link rel=canonical href=https://harshrai654.github.io/blogs/debugging-http-503-uc-errors-in-istio-service-mesh/><link crossorigin=anonymous href=/blogs/assets/css/stylesheet.4a2d4f6ce40ed4a68aae2b504ff6913b1f64bf1b352beea0c885d29c6d987670.css integrity="sha256-Si1PbOQO1KaKritQT/aROx9kvxs1K+6gyIXSnG2YdnA=" rel="preload stylesheet" as=style><link rel=icon href=https://harshrai654.github.io/blogs/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://harshrai654.github.io/blogs/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://harshrai654.github.io/blogs/favicon-32x32.png><link rel=apple-touch-icon href=https://harshrai654.github.io/blogs/apple-touch-icon.png><link rel=mask-icon href=https://harshrai654.github.io/blogs/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://harshrai654.github.io/blogs/debugging-http-503-uc-errors-in-istio-service-mesh/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script data-goatcounter=https://ttharsh.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://harshrai654.github.io/blogs/ accesskey=h title="Learning Loop (Alt + H)">Learning Loop</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://harshrai654.github.io/blogs/>Home</a></div><h1 class="post-title entry-hint-parent">Debugging HTTP 503 UC Errors in Istio Service Mesh</h1><div class=post-meta><span title='2026-01-30 23:43:37 +0530 +0530'>January 30, 2026</span>&nbsp;·&nbsp;10 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#background aria-label=Background>Background</a></li><li><a href=#503-uc-error aria-label="503 UC Error">503 UC Error</a></li><li><a href=#http2 aria-label=HTTP/2>HTTP/2</a></li></ul><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>To obtain more relevant metrics and a comprehensive understanding of traces when external API requests access our systems, We opted to enable tracing for the network mesh components situated above the Kubernetes service. This specifically covers the entire request flow from its initiation: the ingress gateway receives the request and routes it according to defined rules to a particular K8s service; then, the Istio sidecar proxy containers, running alongside our application containers in the same pod, receive and proxy the request to main containers, where our Node.js server process ultimately handle it and generate the appropriate response.
Before enabling tracing for istio mesh, tracing for a HTTP request began when the request reached our application container at the pod level, with HTTP auto-instrumentation serving as the trace root.</p><p><strong>Flow of an external request:</strong></p><pre class=mermaid>
  sequenceDiagram
    autonumber

    participant Client
    participant Ingress as Istio Ingress Gateway
    participant Sidecar as Istio Sidecar (Envoy)
    participant App as Node.js App

    Client -&gt;&gt; Ingress: HTTP request
    Note right of Ingress: Trace root

    Ingress -&gt;&gt; Sidecar: Route to service (mTLS)
    Note right of Sidecar: Envoy inbound span
    Sidecar -&gt;&gt; App: Forward request
    Note right of App: HTTP server span

    App --&gt;&gt; Sidecar: Response
    Sidecar --&gt;&gt; Ingress: Response
    Ingress --&gt;&gt; Client: Response
</pre><p>Following this change, we gained additional spans, with the trace root now identified as the Istio ingress gateway, followed by the sidecar containers of the K8s service pod to which the request was routed, and finally the main Node.js container’s HTTP span.
The primary advantage of this approach is significantly <strong>improved visibility into request failures occurring before the application layer</strong>. Earlier, when issues arose within the network mesh, such as <em>routing failures, mTLS handshakes, or upstream connectivity problems</em>, we would receive alerts from the frontend indicating 5XX errors on API calls, yet observe no corresponding errors in our backend HTTP metrics. This mismatch often caused confusion, as the requests never reached our application containers, and therefore application-level instrumentation could neither record the request nor emit 5XX responses. As a result, our backend alerting was effectively blind to these failure scenarios.
This closes the observability gap by clearly identifying failures occurring before the application layer.
Let’s look at one such issue that occurred at seemingly random intervals, making it difficult to diagnose, and how the additional observability data from the network mesh helped us identify the root cause.</p><h2 id=503-uc-error>503 UC Error<a hidden class=anchor aria-hidden=true href=#503-uc-error>#</a></h2><p>Upon configuring Grafana dashboards for several Istio metrics (sourced from <a href=https://grafana.com/orgs/istio/dashboards>here</a>), we observed numerous 503 errors reported by the ingress gateway across many Kubernetes services, without any specific HTTP API endpoint being consistently implicated.
<img alt="Pasted image 20260130205108.png" loading=lazy src=/blogs/media/pasted-image-20260130205108.png></p><p>With tracing in place, we searched Grafana Tempo (our datasource for traces) using the following TraceQL query:</p><pre tabindex=0><code>{span.http.status_code=&#34;503&#34; &amp;&amp; resource.service.name=&#34;istio-ingressgateway.istio-system&#34;}
</code></pre><p>This allowed us to quickly identify traces corresponding to all such 5XX error cases.
<img alt="Pasted image 20260130205731.png" loading=lazy src=/blogs/media/pasted-image-20260130205731.png>
As shown in the trace above, the request fails at the <strong>Istio ingress gateway and sidecar proxy layers, and no span corresponding to the main application container (Node.js HTTP server) is present.</strong> This indicates that the request never reached the application pod itself.
This also explains the alert mismatch observed earlier: since the failure occurred entirely within the network mesh, application-level HTTP instrumentation never recorded the request and therefore <strong>could not emit 5XX metrics or trigger backend alerts</strong>. With mesh-level tracing enabled, these previously invisible failures are now captured and can be correlated directly with frontend-reported errors.
Having identified the pod where the request failed, we can now query Grafana Loki, our log data source, to check whether the <code>istio-proxy</code> sidecar container recorded any logs. Since the sidecar represents the terminal point for this request within the system, its logs are the most relevant for understanding the failure. Indeed, the following log entry confirms the issue:</p><pre tabindex=0><code class=language-logfmt data-lang=logfmt>[2026-01-27T06:08:22.422Z] &#34;GET ********* HTTP/1.1&#34; 503 UC upstream_reset_before_response_started{connection_termination} - &#34;-&#34; 0 88 50 - &#34;2401:4900:bce9:6781:a4ab:23ff:fec4:3ef4,172.69.152.151&#34; &#34;Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Mobile Safari/537.36&#34; &#34;c1e87fc8-e7d0-9f67-8bfe-42be707c9b25&#34; &#34;api.xyz.com&#34; &#34;10.88.4.251:3000&#34; inbound|3000|| 127.0.0.6:33183 10.88.4.251:3000 XX.XX.XX.XX:0 - default
</code></pre><p>The key part of the log entry is <code>503 UC upstream_reset_before_response_started{connection_termination}</code>. This indicates that when the sidecar proxy forwarded the request to the upstream service (the main application container), the upstream closed or reset the connection before any response could be sent.
Envoy interprets this as an upstream connection termination, and consequently returns a 503 error to the downstream client.
After investigating the issue and discussing it extensively, including exploring insights with LLMs, we arrived at an interesting finding that ultimately pointed to the <a href=https://github.com/istio/istio/issues/55138#issuecomment-2666855044>root cause</a>: the connection was being terminated by the upstream application container. Before diving into that, it is important to briefly outline the layered nature of a network request in our setup.
From the very start, a request passes through multiple entities: <strong>The cloud load balancer, the ingress gateway inside the Kubernetes cluster, the Istio sidecar proxy, and finally the main application container.</strong> Each of these components maintains its own set of connections and, in most cases, its own connection pools. When a new request arrives, it may reuse an existing connection or establish a new one for forwarding the request upstream. As a result, a single logical request is often carried across a chain of independent network connections before the packet reaches its final destination.
In an <code>Istio</code> service mesh, communication between proxies is secured using <code>mTLS</code> and typically happens over HTTP/2, while traffic forwarded from the sidecar to the main application container is usually downgraded to HTTP/1.1. <strong>Each end of these connections enforces its own keep-alive and idle timeout policies, and once a connection remains idle beyond the configured threshold, it may be closed by that endpoint.</strong> The exact network signal used to close the connection, such as a graceful close or a reset, depends on the protocol in use.
This layered connection model and protocol behaviour form an important context for understanding what we observe next.</p><pre class=mermaid>
  sequenceDiagram
    autonumber

    participant Envoy as Istio Sidecar (Envoy)
    participant Node as Node.js App
    participant OS as Kernel TCP Stack

    Note over Envoy,Node: HTTP/1.1 keep-alive connection (idle)

    Node -&gt;&gt; OS: Keep-alive timeout expires
    OS -&gt;&gt; Envoy: TCP FIN (graceful close)

    Note over Envoy: Connection still appears reusable

    Envoy -&gt;&gt; OS: Send new HTTP request on same socket
    OS -&gt;&gt; Envoy: TCP RST (socket already closed)

    Envoy -&gt;&gt; Envoy: Mark upstream reset
    Note right of Envoy: 503 UC\nupstream_reset_before_response_started
</pre><p>By default, a <strong>Node.js HTTP server enforces a keep-alive timeout of around 5 seconds</strong>. If the connection between the Istio sidecar and the Node.js application container remains idle beyond this threshold, the Node.js process initiates a graceful shutdown of the HTTP/1.1 connection by <strong>sending a TCP FIN</strong>.
However, a race condition can occur if, around the same time, the sidecar forwards a new downstream request and attempts to reuse this connection. In such cases, the request is <strong>written to a socket that has already been closed by the application</strong>. The operating system’s TCP stack then responds <strong>with a TCP RST</strong>, indicating that the connection is no longer valid.
From Envoy’s perspective, this manifests as an upstream connection reset before any response headers are received. As a result, the sidecar treats this as a network-level failure and returns a <code>503 UC (upstream_reset_before_response_started)</code> error to the downstream client.</p><blockquote><p>This failure occurs in the narrow window where the upstream has already initiated a graceful connection close, but the sidecar has not yet observed the FIN and therefore attempts to reuse the same connection.</p></blockquote><p>The fix for this issue is relatively straightforward: we need to ensure that <em>idle connections are closed by downstream components before the Node.js process in the main container initiates the close</em>. This prevents Envoy from reusing a connection that the application has already decided to terminate.
By default, the Istio sidecar proxy and the ingress gateway maintain upstream connections with idle timeouts of around one hour in most configurations. Reducing these timeouts to values lower than Node.js’s default 5 seconds is not a viable option, <strong>as it would lead to excessive connection churn, increased TLS handshake overhead, and degraded performance</strong>.
On the other hand, increasing the Node.js HTTP server’s keep-alive timeout to match Envoy’s one-hour timeout is also undesirable, since it would cause the application to retain a large number of idle connections, <strong>potentially resulting in unnecessary memory usage and file descriptor pressure.</strong>
In our setup, there is an additional network component upstream of the Istio ingress gateway, A cloud provider load balancer, with an idle connection timeout of 30 seconds. This effectively places a hard upper bound on how long idle downstream connections can exist, as they will be terminated by the load balancer regardless of Envoy or application-level settings.
Given this constraint, the optimal solution is to configure the Node.js HTTP server’s keep-alive timeout to be slightly higher than the load balancer’s idle timeout (for example, just above 30 seconds). This ensures that idle connections are consistently closed by downstream entities first, eliminating the race condition where Envoy might attempt to reuse a connection that the application has already closed.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl><span class=kr>const</span> <span class=nx>server</span> <span class=o>=</span> <span class=nx>http</span><span class=p>.</span><span class=nx>createServer</span><span class=p>(</span><span class=nx>app</span><span class=p>).</span><span class=nx>listen</span><span class=p>(</span><span class=nx>port</span><span class=p>);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nx>server</span><span class=p>.</span><span class=nx>keepAliveTimeout</span> <span class=o>=</span> <span class=mi>45</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>;</span> <span class=c1>// 45 seconds
</span></span></span></code></pre></div><h2 id=http2>HTTP/2<a hidden class=anchor aria-hidden=true href=#http2>#</a></h2><p>If you read the issue comment linked below, which discusses the same problem, you will notice a recurring mention of HTTP/2, which is used internally by the Istio service mesh. This is also evident from the trace shown earlier, where the communication between the ingress gateway and the sidecar proxy uses HTTP/2, while the failed connection to the main application container occurs over HTTP/1.1.</p><p><a href=https://github.com/istio/istio/issues/55138#issuecomment-2666855044>https://github.com/istio/istio/issues/55138#issuecomment-2666855044</a></p><blockquote><p>No HTTP server runtime that I have ever seen has such a ridiculously high HTTP persistent connection keep-alive timeout of <strong>one hour</strong> or longer.</p><p>Note that this high keep-alive timeout in Envoy/Istio is only an issue for the <strong>inbound cluster</strong> of the sidecar of a particular server workload. That <strong>1h</strong> keep-alive timeout default is also used for the HTTP Connection Manager (HCM) of the downstream listener and the upstream cluster for the HTTP/2 mTLS istio↔istio connections, where high client-side HTTP keep-alive timeouts are <em>not</em> an issue. This is because HTTP/2—used for Istio↔Istio communication—provides additional mechanisms (such as the GOAWAY frame) to gracefully close connections without abruptly terminating the underlying TCP socket.</p><p>The issue lies specifically with HTTP/1.1 connections from the Istio/Envoy sidecar’s inbound cluster to the application server running inside the main container.</p></blockquote><p>In short, high keep-alive timeouts are far less problematic for HTTP/2 connections because connection lifecycle is managed at the stream level rather than solely at the TCP socket level. HTTP/2 allows a server to signal intent to stop accepting new streams using a GOAWAY frame, while still keeping the underlying connection open long enough for in-flight requests to complete. This avoids the abrupt connection termination patterns commonly seen with HTTP/1.1, where closing an idle connection often translates directly into a TCP FIN and can lead to race conditions during connection reuse.</p><p>As a result, the one-hour keep-alive default in Istio is safe for HTTP/2-based Istio-to-Istio communication, but becomes problematic only when applied to HTTP/1.1 connections between the sidecar proxy and the application container.</p><p>A simplistic sequence diagram of HTTP/2 connection&rsquo;s graceful shutdown.</p><pre class=mermaid>
  sequenceDiagram
    autonumber

    participant Client as Envoy Client
    participant Server as Envoy Server

    %% Connection setup
    Client -&gt;&gt; Server: TCP handshake
    Client -&gt;&gt; Server: TLS handshake (mTLS)
    Client -&gt;&gt; Server: HTTP/2 connection preface
    Client -&gt;&gt; Server: SETTINGS frame
    Server -&gt;&gt; Client: SETTINGS frame (ACK)

    Note over Client,Server: Single TCP connection - Multiple concurrent streams

    %% Normal request/response
    Client -&gt;&gt; Server: HEADERS (Stream 1)
    Server -&gt;&gt; Client: HEADERS + DATA (Stream 1)

    %% Graceful shutdown
    Server -&gt;&gt; Client: GOAWAY (last_stream_id = N)
    Note right of Client: No new streams allowed - Existing streams may continue

    Client -&gt;&gt; Server: DATA (Streams ≤ N)
    Server -&gt;&gt; Client: DATA (Streams ≤ N)

    %% Final close
    Server -&gt;&gt; Client: TCP FIN
    Client -&gt;&gt; Server: TCP ACK
</pre><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ul><li><a href=https://github.com/istio/istio/issues/55138#issuecomment-2666855044>https://github.com/istio/istio/issues/55138#issuecomment-2666855044</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://harshrai654.github.io/blogs/tags/networking/>Networking</a></li><li><a href=https://harshrai654.github.io/blogs/tags/nodejs/>NodeJS</a></li><li><a href=https://harshrai654.github.io/blogs/tags/tcp/>TCP</a></li><li><a href=https://harshrai654.github.io/blogs/tags/containers/>Containers</a></li><li><a href=https://harshrai654.github.io/blogs/tags/kubernetes/>Kubernetes</a></li><li><a href=https://harshrai654.github.io/blogs/tags/observability/>Observability</a></li></ul><nav class=paginav><a class=next href=https://harshrai654.github.io/blogs/networking-basics/><span class=title>Next »</span><br><span>Networking Basics</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Debugging HTTP 503 UC Errors in Istio Service Mesh on x" href="https://x.com/intent/tweet/?text=Debugging%20HTTP%20503%20UC%20Errors%20in%20Istio%20Service%20Mesh&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2fdebugging-http-503-uc-errors-in-istio-service-mesh%2f&amp;hashtags=Networking%2cNodeJS%2cTCP%2cContainers%2cKubernetes%2cObservability"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Debugging HTTP 503 UC Errors in Istio Service Mesh on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2fdebugging-http-503-uc-errors-in-istio-service-mesh%2f&amp;title=Debugging%20HTTP%20503%20UC%20Errors%20in%20Istio%20Service%20Mesh&amp;summary=Debugging%20HTTP%20503%20UC%20Errors%20in%20Istio%20Service%20Mesh&amp;source=https%3a%2f%2fharshrai654.github.io%2fblogs%2fdebugging-http-503-uc-errors-in-istio-service-mesh%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Debugging HTTP 503 UC Errors in Istio Service Mesh on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fharshrai654.github.io%2fblogs%2fdebugging-http-503-uc-errors-in-istio-service-mesh%2f&title=Debugging%20HTTP%20503%20UC%20Errors%20in%20Istio%20Service%20Mesh"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Debugging HTTP 503 UC Errors in Istio Service Mesh on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fharshrai654.github.io%2fblogs%2fdebugging-http-503-uc-errors-in-istio-service-mesh%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Debugging HTTP 503 UC Errors in Istio Service Mesh on whatsapp" href="https://api.whatsapp.com/send?text=Debugging%20HTTP%20503%20UC%20Errors%20in%20Istio%20Service%20Mesh%20-%20https%3a%2f%2fharshrai654.github.io%2fblogs%2fdebugging-http-503-uc-errors-in-istio-service-mesh%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Debugging HTTP 503 UC Errors in Istio Service Mesh on telegram" href="https://telegram.me/share/url?text=Debugging%20HTTP%20503%20UC%20Errors%20in%20Istio%20Service%20Mesh&amp;url=https%3a%2f%2fharshrai654.github.io%2fblogs%2fdebugging-http-503-uc-errors-in-istio-service-mesh%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Debugging HTTP 503 UC Errors in Istio Service Mesh on ycombinator" href="https://news.ycombinator.com/submitlink?t=Debugging%20HTTP%20503%20UC%20Errors%20in%20Istio%20Service%20Mesh&u=https%3a%2f%2fharshrai654.github.io%2fblogs%2fdebugging-http-503-uc-errors-in-istio-service-mesh%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://harshrai654.github.io/blogs/>Learning Loop</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs";

  
  function isDarkMode() {
    return (
      document.body.classList.contains("dark") ||
      localStorage.getItem("pref-theme") === "dark" ||
      (!localStorage.getItem("pref-theme") &&
        window.matchMedia("(prefers-color-scheme: dark)").matches)
    );
  }

  
  mermaid.initialize({
    startOnLoad: true,
    theme: isDarkMode() ? "dark" : "default",
    themeVariables: {
      dark: {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#ffffff",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#ffffff",
        secondaryColor: "#4ecdc4",
        tertiaryColor: "#45b7d1",
        background: "#1a1a1a",
        mainBkg: "#2d2d2d",
        secondBkg: "#3d3d3d",
        tertiaryBkg: "#4d4d4d",
      },
      default: {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#000000",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#000000",
        secondaryColor: "#4ecdc4",
        tertiaryColor: "#45b7d1",
      },
    },
  });

  
  const themeToggle = document.getElementById("theme-toggle");
  if (themeToggle) {
    themeToggle.addEventListener("click", () => {
      setTimeout(() => {
        mermaid.initialize({
          startOnLoad: false,
          theme: isDarkMode() ? "dark" : "default",
          themeVariables: {
            dark: {
              primaryColor: "#ff6b6b",
              primaryTextColor: "#ffffff",
              primaryBorderColor: "#ff6b6b",
              lineColor: "#ffffff",
              secondaryColor: "#4ecdc4",
              tertiaryColor: "#45b7d1",
              background: "#1a1a1a",
              mainBkg: "#2d2d2d",
              secondBkg: "#3d3d3d",
              tertiaryBkg: "#4d4d4d",
            },
            default: {
              primaryColor: "#ff6b6b",
              primaryTextColor: "#000000",
              primaryBorderColor: "#ff6b6b",
              lineColor: "#000000",
              secondaryColor: "#4ecdc4",
              tertiaryColor: "#45b7d1",
            },
          },
        });

        
        document.querySelectorAll(".mermaid").forEach((element) => {
          element.removeAttribute("data-processed");
          mermaid.init(undefined, element);
        });
      }, 100);
    });
  }
</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>