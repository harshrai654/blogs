<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Networking on Learning Loop</title><link>https://harshrai654.github.io/blogs/tags/networking/</link><description>Recent content in Networking on Learning Loop</description><generator>Hugo -- 0.145.0</generator><language>en-us</language><lastBuildDate>Sun, 06 Apr 2025 14:21:54 +0530</lastBuildDate><atom:link href="https://harshrai654.github.io/blogs/tags/networking/index.xml" rel="self" type="application/rss+xml"/><item><title>Debugging Redis Latency</title><link>https://harshrai654.github.io/blogs/debugging-redis-latency/</link><pubDate>Sun, 06 Apr 2025 14:21:54 +0530</pubDate><guid>https://harshrai654.github.io/blogs/debugging-redis-latency/</guid><description>&lt;p>This article is about how at work we solved the issue of high response time while executing Redis commands from Node.js server to a Redis compatible database known as dragonfly.&lt;/p>
&lt;h2 id="background">Background&lt;/h2>
&lt;p>After introducing metrics to our Node.js service, we started recording the overall response time whenever a Redis command was executed. We had a wrapper service around a Redis driver known as &lt;code>ioredis&lt;/code> for interacting with our Redis-compatible database.
Once we set up Grafana dashboards for metrics like cache latency, we saw unusually high p99 latency numbers, close to 200ms. This is a very large number, especially considering the underlying database query itself typically takes less than 10ms to complete. To understand &lt;em>why&lt;/em> this latency was so high, we needed more detailed insight than metrics alone could provide. As part of a broader effort to set up our observability stack, I had been exploring various tracing solutions â€“ options ranged from open-source SDKs (&lt;a href="https://opentelemetry.io/docs/languages/js/">OpenTelemetry Node.js SDK&lt;/a>) with a self-deployed trace backend, to third-party managed solutions (Datadog, Middleware, etc.). For this investigation, we decided to proceed with a self-hosted &lt;a href="https://grafana.com/oss/tempo/">Grafana Tempo&lt;/a> instance to test the setup and feasibility. (So far, the setup is working great, and I&amp;rsquo;m planning a detailed blog post on our observability architecture soon). With tracing set up, we could get a waterfall view of the path taken by the service while responding to things like HTTP requests or event processing, which we hoped would pinpoint the source of the delay in our Redis command execution.&lt;/p></description></item><item><title>Socket File Descriptor and TCP connections</title><link>https://harshrai654.github.io/blogs/socket-file-descriptor-and-tcp-connections/</link><pubDate>Sun, 02 Mar 2025 16:15:01 +0530</pubDate><guid>https://harshrai654.github.io/blogs/socket-file-descriptor-and-tcp-connections/</guid><description>&lt;h2 id="socket-file-descriptors-and-their-kernel-structures">Socket File Descriptors and Their Kernel Structures&lt;/h2>
&lt;ul>
&lt;li>A &lt;strong>socket&lt;/strong> is a special type of file descriptor (FD) in Linux, represented as &lt;code>socket:[inode]&lt;/code>.&lt;/li>
&lt;li>Unlike regular file FDs, socket FDs point to &lt;strong>in-memory kernel structures&lt;/strong>, not disk inodes.&lt;/li>
&lt;li>The &lt;code>/proc/&amp;lt;pid&amp;gt;/fd&lt;/code> directory lists all FDs for a process, including sockets.&lt;/li>
&lt;li>The &lt;strong>inode number&lt;/strong> of a socket can be used to inspect its details via tools like &lt;code>ss&lt;/code> and &lt;code>/proc/net/tcp&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h4 id="example-checking-open-fds-for-process-216">Example: Checking Open FDs for Process &lt;code>216&lt;/code>&lt;/h4>
&lt;pre tabindex="0">&lt;code>ls -l /proc/216/fd
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p></description></item></channel></rss>