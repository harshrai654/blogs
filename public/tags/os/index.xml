<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>OS on Learning Loop</title><link>https://harshrai654.github.io/blogs/tags/os/</link><description>Recent content in OS on Learning Loop</description><generator>Hugo -- 0.145.0</generator><language>en-us</language><lastBuildDate>Sun, 02 Mar 2025 16:15:01 +0530</lastBuildDate><atom:link href="https://harshrai654.github.io/blogs/tags/os/index.xml" rel="self" type="application/rss+xml"/><item><title>Socket File Descriptor and TCP connections</title><link>https://harshrai654.github.io/blogs/socket-file-descriptor-and-tcp-connections/</link><pubDate>Sun, 02 Mar 2025 16:15:01 +0530</pubDate><guid>https://harshrai654.github.io/blogs/socket-file-descriptor-and-tcp-connections/</guid><description>&lt;h2 id="socket-file-descriptors-and-their-kernel-structures">Socket File Descriptors and Their Kernel Structures&lt;/h2>
&lt;ul>
&lt;li>A &lt;strong>socket&lt;/strong> is a special type of file descriptor (FD) in Linux, represented as &lt;code>socket:[inode]&lt;/code>.&lt;/li>
&lt;li>Unlike regular file FDs, socket FDs point to &lt;strong>in-memory kernel structures&lt;/strong>, not disk inodes.&lt;/li>
&lt;li>The &lt;code>/proc/&amp;lt;pid&amp;gt;/fd&lt;/code> directory lists all FDs for a process, including sockets.&lt;/li>
&lt;li>The &lt;strong>inode number&lt;/strong> of a socket can be used to inspect its details via tools like &lt;code>ss&lt;/code> and &lt;code>/proc/net/tcp&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h4 id="example-checking-open-fds-for-process-216">Example: Checking Open FDs for Process &lt;code>216&lt;/code>&lt;/h4>
&lt;pre tabindex="0">&lt;code>ls -l /proc/216/fd
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p></description></item><item><title>Files And Directories</title><link>https://harshrai654.github.io/blogs/files-and-directories/</link><pubDate>Sun, 23 Feb 2025 20:41:00 +0000</pubDate><guid>https://harshrai654.github.io/blogs/files-and-directories/</guid><description>&lt;h1 id="files-and-directories">Files and directories&lt;/h1>
&lt;p>File systems virtualize persistent storage (e.g., hard drives, SSDs) into user-friendly files and directories, adding a third pillar to OS abstractions (processes for CPU, address spaces for memory).&lt;/p>
&lt;h2 id="file-paths-and-system-calls">File Paths and System Calls&lt;/h2>
&lt;p>Files are organized in a &lt;strong>tree-like directory structure&lt;/strong>, starting from the root (/). A fileâ€™s location is identified by its &lt;strong>pathname&lt;/strong> (e.g., /home/user/file.txt). To interact with files, processes use &lt;strong>system calls&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>open(path, flags)&lt;/strong>: Opens a file and returns a &lt;strong>file descriptor&lt;/strong> (fd).&lt;/li>
&lt;li>&lt;strong>read(fd, buffer, size)&lt;/strong>: Reads data from the file into a buffer using the fd.&lt;/li>
&lt;li>&lt;strong>write(fd, buffer, size)&lt;/strong>: Writes data to the file via the fd.&lt;/li>
&lt;li>&lt;strong>close(fd)&lt;/strong>: Closes the file, freeing the fd.&lt;/li>
&lt;/ul>
&lt;h2 id="file-descriptors">File Descriptors&lt;/h2>
&lt;p>A &lt;strong>file descriptor&lt;/strong> is a small integer, unique to each process, that identifies an open file. When a process calls open(), the operating system assigns it the next available fd (e.g., 3, 4, etc.). Every process starts with three default fds:&lt;/p></description></item><item><title>Multilevel Page table</title><link>https://harshrai654.github.io/blogs/multilevel-page-table/</link><pubDate>Tue, 26 Nov 2024 20:29:34 +0530</pubDate><guid>https://harshrai654.github.io/blogs/multilevel-page-table/</guid><description>&lt;h1 id="segmented-page-table">Segmented Page Table&lt;/h1>
&lt;p>Page table can grow large for a 32-bit address space and 4 KB page size we will be using 20 bits for virtual page number resulting in 2^20 bytes (i.e. 4MB of page table) for a single page table and each process will have its own page table so it is possible that we will be storing ~100sMB for page table alone which is not good.
&lt;img alt="Pasted image 20241127093849.png" loading="lazy" src="https://harshrai654.github.io/blogs/media/pasted-image-20241127093849.png">
For above page table with 4 bits for VPN (Virtual page number) we can see that only VPN 0,4,14 and 15 are valid i.e. pointing to a PFN (Physical Frame Number) other PTEs (Page table entry) are just taking up space which is not used.
We can use segmentation here with base and bound registers for each page table to only store valid PTE in the table.
&lt;img alt="Pasted image 20241127094506.png" loading="lazy" src="https://harshrai654.github.io/blogs/media/pasted-image-20241127094506.png">
This will again split the virtual address to also contain the segment bits to identify which segment the address belongs to (code, heap or stack). Instead of using &lt;em>Base Page Table Register&lt;/em> to query page table we will now be using &lt;em>Base Page Table Register [Segment]&lt;/em> to get page table physical address for a given segment.&lt;/p></description></item><item><title>TLB</title><link>https://harshrai654.github.io/blogs/tlb/</link><pubDate>Wed, 20 Nov 2024 22:26:06 +0530</pubDate><guid>https://harshrai654.github.io/blogs/tlb/</guid><description>&lt;h1 id="tlb">TLB&lt;/h1>
&lt;p>Translation look-aside buffer is a CPU cache which is generally small but since it is closer to CPU a TLB hit results in address translation to happen in 1-5 CPU cycles.&lt;/p>
&lt;blockquote>
&lt;p>CPU Cycle
Time taken by CPU to fully execute an instruction, while CPU frequency refers to the number of these cycles that occur per second&lt;/p>&lt;/blockquote>
&lt;p>A TLB hit means for given virtual address the physical frame number was found in the TLB cache. A TLB hit will benefit all the address that lie on the same page.
&lt;img alt="Pasted image 20241120223520.png" loading="lazy" src="https://harshrai654.github.io/blogs/media/pasted-image-20241120223520.png">
In the above given image page size is 16 bytes, so 4 INT variables can be saved in a single page, so a TLB hit of VPN 07 will serve address translation for VPN = 07 + page of offset of 0, 4,8 and 12 byte.
This type of caching is benefitted from &lt;em>&lt;strong>spatial locality&lt;/strong>&lt;/em> of data where a cache hit results in cache hits for surrounding data as well.
If we cache data and other data points which are more probable to get accessed in the same time frame (like loop variables etc) then such caching is benefitted from &lt;em>&lt;strong>Temporal locality.&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>Page Tables</title><link>https://harshrai654.github.io/blogs/page-tables/</link><pubDate>Sun, 17 Nov 2024 20:22:15 +0530</pubDate><guid>https://harshrai654.github.io/blogs/page-tables/</guid><description>&lt;h1 id="page-tables">Page Tables&lt;/h1>
&lt;p>Page table contains the translation information of virtual page number to physical frame number.
For an address space of 32 bits and page size of 4 KB &lt;em>(i.e. memory of 2^32 is divided into segments of 4 KB where each segment is called a memory page)&lt;/em> , The virtual address will be of size 32 bits of which 12 bits (2^12 = 4 KB) will be used as offset inside a single page whereas remaining 20 bits will be used as virtual page number&lt;/p></description></item></channel></rss>